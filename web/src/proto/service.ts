// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "service.proto" (package "service", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * Report-related messages
 *
 * @generated from protobuf message service.GenerateReportRequest
 */
export interface GenerateReportRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GenerateReportResponse
 */
export interface GenerateReportResponse {
    /**
     * @generated from protobuf field: string report_id = 1
     */
    reportId: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: int32 score = 3
     */
    score: number;
    /**
     * @generated from protobuf field: string risk_tier = 4
     */
    riskTier: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ListReportsRequest
 */
export interface ListReportsRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string; // Optional filter
}
/**
 * @generated from protobuf message service.Report
 */
export interface Report {
    /**
     * @generated from protobuf field: string report_id = 1
     */
    reportId: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: int32 score = 4
     */
    score: number;
    /**
     * @generated from protobuf field: string risk_tier = 5
     */
    riskTier: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 6
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ListReportsResponse
 */
export interface ListReportsResponse {
    /**
     * @generated from protobuf field: repeated service.Report reports = 1
     */
    reports: Report[];
}
/**
 * @generated from protobuf message service.GetReportByIdRequest
 */
export interface GetReportByIdRequest {
    /**
     * @generated from protobuf field: string report_id = 1
     */
    reportId: string;
}
/**
 * @generated from protobuf message service.GetReportByIdResponse
 */
export interface GetReportByIdResponse {
    /**
     * @generated from protobuf field: service.Report report = 1
     */
    report?: Report;
}
/**
 * @generated from protobuf message service.CalculateRiskScoreRequest
 */
export interface CalculateRiskScoreRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.CalculateRiskScoreResponse
 */
export interface CalculateRiskScoreResponse {
    /**
     * @generated from protobuf field: int32 score = 1
     */
    score: number;
    /**
     * @generated from protobuf field: string risk_tier = 2
     */
    riskTier: string;
}
/**
 * User-related messages
 *
 * @generated from protobuf message service.CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * @generated from protobuf field: string first_name = 1
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 2
     */
    lastName: string;
    /**
     * @generated from protobuf field: string email = 3
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 4
     */
    password: string;
    /**
     * @generated from protobuf field: bool is_admin = 5
     */
    isAdmin: boolean;
}
/**
 * @generated from protobuf message service.CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message service.GetUserRequest
 */
export interface GetUserRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message service.GetUserResponse
 */
export interface GetUserResponse {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string first_name = 2
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 3
     */
    lastName: string;
    /**
     * @generated from protobuf field: string email = 4
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 5
     */
    isAdmin: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 6
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string first_name = 2
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 3
     */
    lastName: string;
    /**
     * @generated from protobuf field: string email = 4
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 5
     */
    password: string;
}
/**
 * @generated from protobuf message service.UpdateUserResponse
 */
export interface UpdateUserResponse {
}
/**
 * @generated from protobuf message service.DeleteUserRequest
 */
export interface DeleteUserRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message service.DeleteUserResponse
 */
export interface DeleteUserResponse {
}
/**
 * @generated from protobuf message service.ListUsersRequest
 */
export interface ListUsersRequest {
}
/**
 * @generated from protobuf message service.ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * @generated from protobuf field: repeated service.User users = 1
     */
    users: User[];
}
/**
 * @generated from protobuf message service.User
 */
export interface User {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string first_name = 2
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 3
     */
    lastName: string;
    /**
     * @generated from protobuf field: string email = 4
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 5
     */
    isAdmin: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 6
     */
    createdAt?: Timestamp;
}
/**
 * API Key-related messages (MOVED FROM AUTH SERVICE)
 *
 * @generated from protobuf message service.CreateAPIKeyRequest
 */
export interface CreateAPIKeyRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string role = 2
     */
    role: string; // "admin", "user", or "viewer"
    /**
     * @generated from protobuf field: bool is_service_key = 3
     */
    isServiceKey: boolean;
}
/**
 * @generated from protobuf message service.CreateAPIKeyResponse
 */
export interface CreateAPIKeyResponse {
    /**
     * @generated from protobuf field: string api_key = 1
     */
    apiKey: string;
    /**
     * @generated from protobuf field: string role = 2
     */
    role: string;
    /**
     * @generated from protobuf field: bool is_service_key = 3
     */
    isServiceKey: boolean;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 4
     */
    expiresAt?: Timestamp;
}
/**
 * @generated from protobuf message service.RotateAPIKeyRequest
 */
export interface RotateAPIKeyRequest {
    /**
     * @generated from protobuf field: string api_key = 1
     */
    apiKey: string;
}
/**
 * @generated from protobuf message service.RotateAPIKeyResponse
 */
export interface RotateAPIKeyResponse {
    /**
     * @generated from protobuf field: string new_api_key = 1
     */
    newApiKey: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 2
     */
    expiresAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ActivateAPIKeyRequest
 */
export interface ActivateAPIKeyRequest {
    /**
     * @generated from protobuf field: string api_key = 1
     */
    apiKey: string;
}
/**
 * @generated from protobuf message service.ActivateAPIKeyResponse
 */
export interface ActivateAPIKeyResponse {
}
/**
 * @generated from protobuf message service.DeactivateAPIKeyRequest
 */
export interface DeactivateAPIKeyRequest {
    /**
     * @generated from protobuf field: string api_key = 1
     */
    apiKey: string;
    /**
     * @generated from protobuf field: string deactivation_message = 2
     */
    deactivationMessage: string;
}
/**
 * @generated from protobuf message service.DeactivateAPIKeyResponse
 */
export interface DeactivateAPIKeyResponse {
}
/**
 * @generated from protobuf message service.ListAPIKeysRequest
 */
export interface ListAPIKeysRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
}
/**
 * @generated from protobuf message service.ListAPIKeysResponse
 */
export interface ListAPIKeysResponse {
    /**
     * @generated from protobuf field: repeated service.APIKey api_keys = 1
     */
    apiKeys: APIKey[];
}
/**
 * @generated from protobuf message service.APIKey
 */
export interface APIKey {
    /**
     * @generated from protobuf field: string api_key = 1
     */
    apiKey: string;
    /**
     * @generated from protobuf field: string user_id = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string role = 3
     */
    role: string;
    /**
     * @generated from protobuf field: bool is_service_key = 4
     */
    isServiceKey: boolean;
    /**
     * @generated from protobuf field: bool is_active = 5
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: string deactivation_message = 6
     */
    deactivationMessage: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 7
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 8
     */
    expiresAt?: Timestamp;
}
/**
 * Password management messages (NEW)
 *
 * @generated from protobuf message service.ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string old_password = 2
     */
    oldPassword: string;
    /**
     * @generated from protobuf field: string new_password = 3
     */
    newPassword: string;
}
/**
 * @generated from protobuf message service.ChangePasswordResponse
 */
export interface ChangePasswordResponse {
}
/**
 * Auth-related messages
 *
 * @generated from protobuf message service.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * @generated from protobuf message service.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * @generated from protobuf field: string first_name = 2
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 3
     */
    lastName: string;
    /**
     * @generated from protobuf field: bool is_admin = 4
     */
    isAdmin: boolean;
    /**
     * @generated from protobuf field: string token = 5
     */
    token: string;
}
/**
 * @generated from protobuf message service.InviteUserRequest
 */
export interface InviteUserRequest {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 2
     */
    isAdmin: boolean;
}
/**
 * @generated from protobuf message service.InviteUserResponse
 */
export interface InviteUserResponse {
    /**
     * @generated from protobuf field: string invitation_id = 1
     */
    invitationId: string;
    /**
     * @generated from protobuf field: string token = 2
     */
    token: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires_at = 3
     */
    expiresAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ValidateInviteRequest
 */
export interface ValidateInviteRequest {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message service.ValidateInviteResponse
 */
export interface ValidateInviteResponse {
    /**
     * @generated from protobuf field: string email = 1
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 2
     */
    isAdmin: boolean;
}
/**
 * Scan-related messages
 *
 * @generated from protobuf message service.ScanDomainRequest
 */
export interface ScanDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.ScanDomainResponse
 */
export interface ScanDomainResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.DNSSecurityResult result = 2
     */
    result?: DNSSecurityResult;
}
/**
 * @generated from protobuf message service.GetDNSScanResultsByDomainRequest
 */
export interface GetDNSScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetDNSScanResultsByDomainResponse
 */
export interface GetDNSScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.DNSScanResult results = 1
     */
    results: DNSScanResult[];
}
/**
 * @generated from protobuf message service.GetDNSScanResultByIDRequest
 */
export interface GetDNSScanResultByIDRequest {
    /**
     * @generated from protobuf field: string dns_scan_id = 1
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.GetDNSScanResultByIDResponse
 */
export interface GetDNSScanResultByIDResponse {
    /**
     * @generated from protobuf field: service.DNSScanResult result = 1
     */
    result?: DNSScanResult;
}
/**
 * @generated from protobuf message service.DNSScanResult
 */
export interface DNSScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.DNSSecurityResult result = 4
     */
    result?: DNSSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ScanTLSRequest
 */
export interface ScanTLSRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanTLSResponse
 */
export interface ScanTLSResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.TLSSecurityResult result = 2
     */
    result?: TLSSecurityResult;
}
/**
 * @generated from protobuf message service.GetTLSScanResultsByDomainRequest
 */
export interface GetTLSScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetTLSScanResultsByDomainResponse
 */
export interface GetTLSScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.TLSScanResult results = 1
     */
    results: TLSScanResult[];
}
/**
 * @generated from protobuf message service.TLSScanResult
 */
export interface TLSScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.TLSSecurityResult result = 4
     */
    result?: TLSSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ScanCrtShRequest
 */
export interface ScanCrtShRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanCrtShResponse
 */
export interface ScanCrtShResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.CrtShSecurityResult result = 2
     */
    result?: CrtShSecurityResult;
}
/**
 * @generated from protobuf message service.GetCrtShScanResultsByDomainRequest
 */
export interface GetCrtShScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetCrtShScanResultsByDomainResponse
 */
export interface GetCrtShScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.CrtShScanResult results = 1
     */
    results: CrtShScanResult[];
}
/**
 * @generated from protobuf message service.CrtShScanResult
 */
export interface CrtShScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.CrtShSecurityResult result = 4
     */
    result?: CrtShSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ScanChaosRequest
 */
export interface ScanChaosRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanChaosResponse
 */
export interface ScanChaosResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.ChaosSecurityResult result = 2
     */
    result?: ChaosSecurityResult;
}
/**
 * @generated from protobuf message service.GetChaosScanResultsByDomainRequest
 */
export interface GetChaosScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetChaosScanResultsByDomainResponse
 */
export interface GetChaosScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.ChaosScanResult results = 1
     */
    results: ChaosScanResult[];
}
/**
 * @generated from protobuf message service.ChaosScanResult
 */
export interface ChaosScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.ChaosSecurityResult result = 4
     */
    result?: ChaosSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ScanShodanRequest
 */
export interface ScanShodanRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanShodanResponse
 */
export interface ScanShodanResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.ShodanSecurityResult result = 2
     */
    result?: ShodanSecurityResult;
}
/**
 * @generated from protobuf message service.GetShodanScanResultsByDomainRequest
 */
export interface GetShodanScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetShodanScanResultsByDomainResponse
 */
export interface GetShodanScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.ShodanScanResult results = 1
     */
    results: ShodanScanResult[];
}
/**
 * --- Security Result Structures ---
 *
 * @generated from protobuf message service.DNSSecurityResult
 */
export interface DNSSecurityResult {
    /**
     * @generated from protobuf field: string spf_record = 1
     */
    spfRecord: string;
    /**
     * @generated from protobuf field: bool spf_valid = 2
     */
    spfValid: boolean;
    /**
     * @generated from protobuf field: string spf_policy = 3
     */
    spfPolicy: string;
    /**
     * @generated from protobuf field: string dkim_record = 4
     */
    dkimRecord: string;
    /**
     * @generated from protobuf field: bool dkim_valid = 5
     */
    dkimValid: boolean;
    /**
     * @generated from protobuf field: string dkim_validation_error = 6
     */
    dkimValidationError: string;
    /**
     * @generated from protobuf field: string dmarc_record = 7
     */
    dmarcRecord: string;
    /**
     * @generated from protobuf field: string dmarc_policy = 8
     */
    dmarcPolicy: string;
    /**
     * @generated from protobuf field: bool dmarc_valid = 9
     */
    dmarcValid: boolean;
    /**
     * @generated from protobuf field: string dmarc_validation_error = 10
     */
    dmarcValidationError: string;
    /**
     * @generated from protobuf field: bool dnssec_enabled = 11
     */
    dnssecEnabled: boolean;
    /**
     * @generated from protobuf field: bool dnssec_valid = 12
     */
    dnssecValid: boolean;
    /**
     * @generated from protobuf field: string dnssec_validation_error = 13
     */
    dnssecValidationError: string;
    /**
     * @generated from protobuf field: repeated string ip_addresses = 14
     */
    ipAddresses: string[];
    /**
     * @generated from protobuf field: repeated string mx_records = 15
     */
    mxRecords: string[];
    /**
     * @generated from protobuf field: repeated string ns_records = 16
     */
    nsRecords: string[];
    /**
     * @generated from protobuf field: repeated string errors = 17
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.TLSSecurityResult
 */
export interface TLSSecurityResult {
    /**
     * @generated from protobuf field: string tls_version = 1
     */
    tlsVersion: string;
    /**
     * @generated from protobuf field: string cipher_suite = 2
     */
    cipherSuite: string;
    /**
     * @generated from protobuf field: bool hsts_header = 3
     */
    hstsHeader: boolean;
    /**
     * @generated from protobuf field: bool certificate_valid = 4
     */
    certificateValid: boolean;
    /**
     * @generated from protobuf field: string cert_issuer = 5
     */
    certIssuer: string;
    /**
     * @generated from protobuf field: string cert_subject = 6
     */
    certSubject: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp cert_not_before = 7
     */
    certNotBefore?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp cert_not_after = 8
     */
    certNotAfter?: Timestamp;
    /**
     * @generated from protobuf field: repeated string cert_dns_names = 9
     */
    certDnsNames: string[];
    /**
     * @generated from protobuf field: int32 cert_key_strength = 10
     */
    certKeyStrength: number;
    /**
     * @generated from protobuf field: string cert_signature_algorithm = 11
     */
    certSignatureAlgorithm: string;
    /**
     * @generated from protobuf field: repeated string errors = 12
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.CrtShCertificate
 */
export interface CrtShCertificate {
    /**
     * @generated from protobuf field: int64 id = 1
     */
    id: bigint;
    /**
     * @generated from protobuf field: string common_name = 2
     */
    commonName: string;
    /**
     * @generated from protobuf field: string issuer = 3
     */
    issuer: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp not_before = 4
     */
    notBefore?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp not_after = 5
     */
    notAfter?: Timestamp;
    /**
     * @generated from protobuf field: string serial_number = 6
     */
    serialNumber: string;
    /**
     * @generated from protobuf field: repeated string dns_names = 7
     */
    dnsNames: string[];
    /**
     * @generated from protobuf field: string signature_algorithm = 8
     */
    signatureAlgorithm: string;
}
/**
 * @generated from protobuf message service.CrtShSecurityResult
 */
export interface CrtShSecurityResult {
    /**
     * @generated from protobuf field: repeated service.CrtShCertificate certificates = 1
     */
    certificates: CrtShCertificate[];
    /**
     * @generated from protobuf field: repeated string subdomains = 2
     */
    subdomains: string[];
    /**
     * @generated from protobuf field: repeated string errors = 3
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.ChaosSecurityResult
 */
export interface ChaosSecurityResult {
    /**
     * @generated from protobuf field: repeated string subdomains = 1
     */
    subdomains: string[];
    /**
     * @generated from protobuf field: repeated string errors = 2
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.ShodanScanResult
 */
export interface ShodanScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.ShodanSecurityResult result = 4
     */
    result?: ShodanSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ShodanLocation
 */
export interface ShodanLocation {
    /**
     * @generated from protobuf field: string city = 1
     */
    city: string;
    /**
     * @generated from protobuf field: string country_name = 2
     */
    countryName: string;
    /**
     * @generated from protobuf field: float latitude = 3
     */
    latitude: number;
    /**
     * @generated from protobuf field: float longitude = 4
     */
    longitude: number;
}
/**
 * @generated from protobuf message service.ShodanSSL
 */
export interface ShodanSSL {
    /**
     * @generated from protobuf field: string issuer = 1
     */
    issuer: string;
    /**
     * @generated from protobuf field: string subject = 2
     */
    subject: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expires = 3
     */
    expires?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp not_after = 4
     */
    notAfter?: Timestamp;
}
/**
 * @generated from protobuf message service.ShodanMetadata
 */
export interface ShodanMetadata {
    /**
     * @generated from protobuf field: string module = 1
     */
    module: string;
}
/**
 * @generated from protobuf message service.ShodanHost
 */
export interface ShodanHost {
    /**
     * @generated from protobuf field: string ip = 1
     */
    ip: string;
    /**
     * @generated from protobuf field: int32 port = 2
     */
    port: number;
    /**
     * @generated from protobuf field: repeated string hostnames = 3
     */
    hostnames: string[];
    /**
     * @generated from protobuf field: string os = 4
     */
    os: string;
    /**
     * @generated from protobuf field: string banner = 5
     */
    banner: string;
    /**
     * @generated from protobuf field: repeated string tags = 6
     */
    tags: string[];
    /**
     * @generated from protobuf field: service.ShodanLocation location = 7
     */
    location?: ShodanLocation;
    /**
     * @generated from protobuf field: service.ShodanSSL ssl = 8
     */
    ssl?: ShodanSSL;
    /**
     * @generated from protobuf field: repeated string domains = 9
     */
    domains: string[];
    /**
     * @generated from protobuf field: string asn = 10
     */
    asn: string;
    /**
     * @generated from protobuf field: string org = 11
     */
    org: string;
    /**
     * @generated from protobuf field: string isp = 12
     */
    isp: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 13
     */
    timestamp?: Timestamp;
    /**
     * @generated from protobuf field: service.ShodanMetadata shodan_meta = 14
     */
    shodanMeta?: ShodanMetadata;
}
/**
 * @generated from protobuf message service.ShodanSecurityResult
 */
export interface ShodanSecurityResult {
    /**
     * @generated from protobuf field: repeated service.ShodanHost hosts = 1
     */
    hosts: ShodanHost[];
    /**
     * @generated from protobuf field: repeated string errors = 2
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.ScanOTXRequest
 */
export interface ScanOTXRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanOTXResponse
 */
export interface ScanOTXResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.OTXSecurityResult result = 2
     */
    result?: OTXSecurityResult;
}
/**
 * @generated from protobuf message service.GetOTXScanResultsByDomainRequest
 */
export interface GetOTXScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetOTXScanResultsByDomainResponse
 */
export interface GetOTXScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.OTXScanResult results = 1
     */
    results: OTXScanResult[];
}
/**
 * @generated from protobuf message service.OTXScanResult
 */
export interface OTXScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.OTXSecurityResult result = 4
     */
    result?: OTXSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.OTXGeneralInfo
 */
export interface OTXGeneralInfo {
    /**
     * @generated from protobuf field: int32 pulse_count = 1
     */
    pulseCount: number;
    /**
     * @generated from protobuf field: repeated string pulses = 2
     */
    pulses: string[];
}
/**
 * @generated from protobuf message service.OTXMalware
 */
export interface OTXMalware {
    /**
     * @generated from protobuf field: string hash = 1
     */
    hash: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp datetime = 2
     */
    datetime?: Timestamp;
}
/**
 * @generated from protobuf message service.OTXURL
 */
export interface OTXURL {
    /**
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp datetime = 2
     */
    datetime?: Timestamp;
}
/**
 * @generated from protobuf message service.OTXPassiveDNS
 */
export interface OTXPassiveDNS {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: string hostname = 2
     */
    hostname: string;
    /**
     * @generated from protobuf field: string record = 3
     */
    record: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp datetime = 4
     */
    datetime?: Timestamp;
}
/**
 * @generated from protobuf message service.OTXSecurityResult
 */
export interface OTXSecurityResult {
    /**
     * @generated from protobuf field: service.OTXGeneralInfo general_info = 1
     */
    generalInfo?: OTXGeneralInfo;
    /**
     * @generated from protobuf field: repeated service.OTXMalware malware = 2
     */
    malware: OTXMalware[];
    /**
     * @generated from protobuf field: repeated service.OTXURL urls = 3
     */
    urls: OTXURL[];
    /**
     * @generated from protobuf field: repeated service.OTXPassiveDNS passive_dns = 4
     */
    passiveDns: OTXPassiveDNS[];
    /**
     * @generated from protobuf field: repeated string errors = 5
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.ScanWhoisRequest
 */
export interface ScanWhoisRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanWhoisResponse
 */
export interface ScanWhoisResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.WhoisSecurityResult result = 2
     */
    result?: WhoisSecurityResult;
}
/**
 * @generated from protobuf message service.GetWhoisScanResultsByDomainRequest
 */
export interface GetWhoisScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetWhoisScanResultsByDomainResponse
 */
export interface GetWhoisScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.WhoisScanResult results = 1
     */
    results: WhoisScanResult[];
}
/**
 * @generated from protobuf message service.WhoisScanResult
 */
export interface WhoisScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.WhoisSecurityResult result = 4
     */
    result?: WhoisSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.WhoisSecurityResult
 */
export interface WhoisSecurityResult {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string registrar = 2
     */
    registrar: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp creation_date = 3
     */
    creationDate?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expiry_date = 4
     */
    expiryDate?: Timestamp;
    /**
     * @generated from protobuf field: string registrant_name = 5
     */
    registrantName: string;
    /**
     * @generated from protobuf field: repeated string errors = 6
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.AbuseChIOC
 */
export interface AbuseChIOC {
    /**
     * @generated from protobuf field: string ioc_type = 1
     */
    iocType: string;
    /**
     * @generated from protobuf field: string ioc_value = 2
     */
    iocValue: string;
    /**
     * @generated from protobuf field: string threat_type = 3
     */
    threatType: string;
    /**
     * @generated from protobuf field: float confidence = 4
     */
    confidence: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_seen = 5
     */
    firstSeen?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_seen = 6
     */
    lastSeen?: Timestamp;
    /**
     * @generated from protobuf field: repeated string malware_alias = 7
     */
    malwareAlias: string[];
    /**
     * @generated from protobuf field: repeated string tags = 8
     */
    tags: string[];
}
/**
 * @generated from protobuf message service.AbuseChSecurityResult
 */
export interface AbuseChSecurityResult {
    /**
     * @generated from protobuf field: repeated service.AbuseChIOC iocs = 1
     */
    iocs: AbuseChIOC[];
    /**
     * @generated from protobuf field: repeated string errors = 2
     */
    errors: string[];
}
/**
 * @generated from protobuf message service.ScanAbuseChRequest
 */
export interface ScanAbuseChRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanAbuseChResponse
 */
export interface ScanAbuseChResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.AbuseChSecurityResult result = 2
     */
    result?: AbuseChSecurityResult;
}
/**
 * @generated from protobuf message service.GetAbuseChScanResultsByDomainRequest
 */
export interface GetAbuseChScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetAbuseChScanResultsByDomainResponse
 */
export interface GetAbuseChScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.AbuseChScanResult results = 1
     */
    results: AbuseChScanResult[];
}
/**
 * @generated from protobuf message service.AbuseChScanResult
 */
export interface AbuseChScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.AbuseChSecurityResult result = 4
     */
    result?: AbuseChSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ScanISCRequest
 */
export interface ScanISCRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 2
     */
    dnsScanId: string;
}
/**
 * @generated from protobuf message service.ScanISCResponse
 */
export interface ScanISCResponse {
    /**
     * @generated from protobuf field: string scan_id = 1
     */
    scanId: string;
    /**
     * @generated from protobuf field: service.ISCSecurityResult result = 2
     */
    result?: ISCSecurityResult;
}
/**
 * @generated from protobuf message service.GetISCScanResultsByDomainRequest
 */
export interface GetISCScanResultsByDomainRequest {
    /**
     * @generated from protobuf field: string domain = 1
     */
    domain: string;
}
/**
 * @generated from protobuf message service.GetISCScanResultsByDomainResponse
 */
export interface GetISCScanResultsByDomainResponse {
    /**
     * @generated from protobuf field: repeated service.ISCScanResult results = 1
     */
    results: ISCScanResult[];
}
/**
 * @generated from protobuf message service.ISCScanResult
 */
export interface ISCScanResult {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string domain = 2
     */
    domain: string;
    /**
     * @generated from protobuf field: string dns_scan_id = 3
     */
    dnsScanId: string;
    /**
     * @generated from protobuf field: service.ISCSecurityResult result = 4
     */
    result?: ISCSecurityResult;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 5
     */
    createdAt?: Timestamp;
}
/**
 * @generated from protobuf message service.ISCIncident
 */
export interface ISCIncident {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 2
     */
    date?: Timestamp;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: string severity = 4
     */
    severity: string; // e.g., "Low", "Medium", "High"
}
/**
 * @generated from protobuf message service.ISCSecurityResult
 */
export interface ISCSecurityResult {
    /**
     * @generated from protobuf field: repeated service.ISCIncident incidents = 1
     */
    incidents: ISCIncident[];
    /**
     * @generated from protobuf field: string overall_risk = 2
     */
    overallRisk: string;
    /**
     * @generated from protobuf field: repeated string errors = 3
     */
    errors: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class GenerateReportRequest$Type extends MessageType<GenerateReportRequest> {
    constructor() {
        super("service.GenerateReportRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GenerateReportRequest>): GenerateReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GenerateReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReportRequest): GenerateReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GenerateReportRequest
 */
export const GenerateReportRequest = new GenerateReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateReportResponse$Type extends MessageType<GenerateReportResponse> {
    constructor() {
        super("service.GenerateReportResponse", [
            { no: 1, name: "report_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "risk_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GenerateReportResponse>): GenerateReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reportId = "";
        message.dnsScanId = "";
        message.score = 0;
        message.riskTier = "";
        if (value !== undefined)
            reflectionMergePartial<GenerateReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReportResponse): GenerateReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string report_id */ 1:
                    message.reportId = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                case /* int32 score */ 3:
                    message.score = reader.int32();
                    break;
                case /* string risk_tier */ 4:
                    message.riskTier = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string report_id = 1; */
        if (message.reportId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reportId);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        /* int32 score = 3; */
        if (message.score !== 0)
            writer.tag(3, WireType.Varint).int32(message.score);
        /* string risk_tier = 4; */
        if (message.riskTier !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.riskTier);
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GenerateReportResponse
 */
export const GenerateReportResponse = new GenerateReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListReportsRequest$Type extends MessageType<ListReportsRequest> {
    constructor() {
        super("service.ListReportsRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListReportsRequest>): ListReportsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<ListReportsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListReportsRequest): ListReportsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListReportsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListReportsRequest
 */
export const ListReportsRequest = new ListReportsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Report$Type extends MessageType<Report> {
    constructor() {
        super("service.Report", [
            { no: 1, name: "report_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "risk_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Report>): Report {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reportId = "";
        message.domain = "";
        message.dnsScanId = "";
        message.score = 0;
        message.riskTier = "";
        if (value !== undefined)
            reflectionMergePartial<Report>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Report): Report {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string report_id */ 1:
                    message.reportId = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* int32 score */ 4:
                    message.score = reader.int32();
                    break;
                case /* string risk_tier */ 5:
                    message.riskTier = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 6:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Report, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string report_id = 1; */
        if (message.reportId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reportId);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* int32 score = 4; */
        if (message.score !== 0)
            writer.tag(4, WireType.Varint).int32(message.score);
        /* string risk_tier = 5; */
        if (message.riskTier !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.riskTier);
        /* google.protobuf.Timestamp created_at = 6; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.Report
 */
export const Report = new Report$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListReportsResponse$Type extends MessageType<ListReportsResponse> {
    constructor() {
        super("service.ListReportsResponse", [
            { no: 1, name: "reports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Report }
        ]);
    }
    create(value?: PartialMessage<ListReportsResponse>): ListReportsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reports = [];
        if (value !== undefined)
            reflectionMergePartial<ListReportsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListReportsResponse): ListReportsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.Report reports */ 1:
                    message.reports.push(Report.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListReportsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.Report reports = 1; */
        for (let i = 0; i < message.reports.length; i++)
            Report.internalBinaryWrite(message.reports[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListReportsResponse
 */
export const ListReportsResponse = new ListReportsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportByIdRequest$Type extends MessageType<GetReportByIdRequest> {
    constructor() {
        super("service.GetReportByIdRequest", [
            { no: 1, name: "report_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetReportByIdRequest>): GetReportByIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reportId = "";
        if (value !== undefined)
            reflectionMergePartial<GetReportByIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportByIdRequest): GetReportByIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string report_id */ 1:
                    message.reportId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportByIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string report_id = 1; */
        if (message.reportId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reportId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetReportByIdRequest
 */
export const GetReportByIdRequest = new GetReportByIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReportByIdResponse$Type extends MessageType<GetReportByIdResponse> {
    constructor() {
        super("service.GetReportByIdResponse", [
            { no: 1, name: "report", kind: "message", T: () => Report }
        ]);
    }
    create(value?: PartialMessage<GetReportByIdResponse>): GetReportByIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetReportByIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReportByIdResponse): GetReportByIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* service.Report report */ 1:
                    message.report = Report.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReportByIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* service.Report report = 1; */
        if (message.report)
            Report.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetReportByIdResponse
 */
export const GetReportByIdResponse = new GetReportByIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalculateRiskScoreRequest$Type extends MessageType<CalculateRiskScoreRequest> {
    constructor() {
        super("service.CalculateRiskScoreRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CalculateRiskScoreRequest>): CalculateRiskScoreRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<CalculateRiskScoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalculateRiskScoreRequest): CalculateRiskScoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalculateRiskScoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CalculateRiskScoreRequest
 */
export const CalculateRiskScoreRequest = new CalculateRiskScoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalculateRiskScoreResponse$Type extends MessageType<CalculateRiskScoreResponse> {
    constructor() {
        super("service.CalculateRiskScoreResponse", [
            { no: 1, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "risk_tier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CalculateRiskScoreResponse>): CalculateRiskScoreResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.score = 0;
        message.riskTier = "";
        if (value !== undefined)
            reflectionMergePartial<CalculateRiskScoreResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalculateRiskScoreResponse): CalculateRiskScoreResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 score */ 1:
                    message.score = reader.int32();
                    break;
                case /* string risk_tier */ 2:
                    message.riskTier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalculateRiskScoreResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 score = 1; */
        if (message.score !== 0)
            writer.tag(1, WireType.Varint).int32(message.score);
        /* string risk_tier = 2; */
        if (message.riskTier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.riskTier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CalculateRiskScoreResponse
 */
export const CalculateRiskScoreResponse = new CalculateRiskScoreResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
    constructor() {
        super("service.CreateUserRequest", [
            { no: 1, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstName = "";
        message.lastName = "";
        message.email = "";
        message.password = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<CreateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserRequest): CreateUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_name */ 1:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 2:
                    message.lastName = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string password */ 4:
                    message.password = reader.string();
                    break;
                case /* bool is_admin */ 5:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string first_name = 1; */
        if (message.firstName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 2; */
        if (message.lastName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastName);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string password = 4; */
        if (message.password !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.password);
        /* bool is_admin = 5; */
        if (message.isAdmin !== false)
            writer.tag(5, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserResponse$Type extends MessageType<CreateUserResponse> {
    constructor() {
        super("service.CreateUserResponse", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserResponse>): CreateUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserResponse): CreateUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CreateUserResponse
 */
export const CreateUserResponse = new CreateUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserRequest$Type extends MessageType<GetUserRequest> {
    constructor() {
        super("service.GetUserRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserRequest>): GetUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserRequest): GetUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetUserRequest
 */
export const GetUserRequest = new GetUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserResponse$Type extends MessageType<GetUserResponse> {
    constructor() {
        super("service.GetUserResponse", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetUserResponse>): GetUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.firstName = "";
        message.lastName = "";
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<GetUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserResponse): GetUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* string email */ 4:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 5:
                    message.isAdmin = reader.bool();
                    break;
                case /* google.protobuf.Timestamp created_at */ 6:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string first_name = 2; */
        if (message.firstName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 3; */
        if (message.lastName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* string email = 4; */
        if (message.email !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 5; */
        if (message.isAdmin !== false)
            writer.tag(5, WireType.Varint).bool(message.isAdmin);
        /* google.protobuf.Timestamp created_at = 6; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetUserResponse
 */
export const GetUserResponse = new GetUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserRequest$Type extends MessageType<UpdateUserRequest> {
    constructor() {
        super("service.UpdateUserRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateUserRequest>): UpdateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.firstName = "";
        message.lastName = "";
        message.email = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserRequest): UpdateUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* string email */ 4:
                    message.email = reader.string();
                    break;
                case /* string password */ 5:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string first_name = 2; */
        if (message.firstName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 3; */
        if (message.lastName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* string email = 4; */
        if (message.email !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* string password = 5; */
        if (message.password !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.UpdateUserRequest
 */
export const UpdateUserRequest = new UpdateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserResponse$Type extends MessageType<UpdateUserResponse> {
    constructor() {
        super("service.UpdateUserResponse", []);
    }
    create(value?: PartialMessage<UpdateUserResponse>): UpdateUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserResponse): UpdateUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.UpdateUserResponse
 */
export const UpdateUserResponse = new UpdateUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserRequest$Type extends MessageType<DeleteUserRequest> {
    constructor() {
        super("service.DeleteUserRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteUserRequest>): DeleteUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteUserRequest): DeleteUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeleteUserRequest
 */
export const DeleteUserRequest = new DeleteUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserResponse$Type extends MessageType<DeleteUserResponse> {
    constructor() {
        super("service.DeleteUserResponse", []);
    }
    create(value?: PartialMessage<DeleteUserResponse>): DeleteUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteUserResponse): DeleteUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeleteUserResponse
 */
export const DeleteUserResponse = new DeleteUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUsersRequest$Type extends MessageType<ListUsersRequest> {
    constructor() {
        super("service.ListUsersRequest", []);
    }
    create(value?: PartialMessage<ListUsersRequest>): ListUsersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListUsersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUsersRequest): ListUsersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUsersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListUsersRequest
 */
export const ListUsersRequest = new ListUsersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUsersResponse$Type extends MessageType<ListUsersResponse> {
    constructor() {
        super("service.ListUsersResponse", [
            { no: 1, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => User }
        ]);
    }
    create(value?: PartialMessage<ListUsersResponse>): ListUsersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<ListUsersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUsersResponse): ListUsersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.User users */ 1:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUsersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.User users = 1; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListUsersResponse
 */
export const ListUsersResponse = new ListUsersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("service.User", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.firstName = "";
        message.lastName = "";
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* string email */ 4:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 5:
                    message.isAdmin = reader.bool();
                    break;
                case /* google.protobuf.Timestamp created_at */ 6:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string first_name = 2; */
        if (message.firstName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 3; */
        if (message.lastName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* string email = 4; */
        if (message.email !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 5; */
        if (message.isAdmin !== false)
            writer.tag(5, WireType.Varint).bool(message.isAdmin);
        /* google.protobuf.Timestamp created_at = 6; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAPIKeyRequest$Type extends MessageType<CreateAPIKeyRequest> {
    constructor() {
        super("service.CreateAPIKeyRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_service_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAPIKeyRequest>): CreateAPIKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.role = "";
        message.isServiceKey = false;
        if (value !== undefined)
            reflectionMergePartial<CreateAPIKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAPIKeyRequest): CreateAPIKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* bool is_service_key */ 3:
                    message.isServiceKey = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAPIKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* bool is_service_key = 3; */
        if (message.isServiceKey !== false)
            writer.tag(3, WireType.Varint).bool(message.isServiceKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CreateAPIKeyRequest
 */
export const CreateAPIKeyRequest = new CreateAPIKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAPIKeyResponse$Type extends MessageType<CreateAPIKeyResponse> {
    constructor() {
        super("service.CreateAPIKeyResponse", [
            { no: 1, name: "api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_service_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CreateAPIKeyResponse>): CreateAPIKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKey = "";
        message.role = "";
        message.isServiceKey = false;
        if (value !== undefined)
            reflectionMergePartial<CreateAPIKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAPIKeyResponse): CreateAPIKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_key */ 1:
                    message.apiKey = reader.string();
                    break;
                case /* string role */ 2:
                    message.role = reader.string();
                    break;
                case /* bool is_service_key */ 3:
                    message.isServiceKey = reader.bool();
                    break;
                case /* google.protobuf.Timestamp expires_at */ 4:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAPIKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_key = 1; */
        if (message.apiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        /* string role = 2; */
        if (message.role !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.role);
        /* bool is_service_key = 3; */
        if (message.isServiceKey !== false)
            writer.tag(3, WireType.Varint).bool(message.isServiceKey);
        /* google.protobuf.Timestamp expires_at = 4; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CreateAPIKeyResponse
 */
export const CreateAPIKeyResponse = new CreateAPIKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RotateAPIKeyRequest$Type extends MessageType<RotateAPIKeyRequest> {
    constructor() {
        super("service.RotateAPIKeyRequest", [
            { no: 1, name: "api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RotateAPIKeyRequest>): RotateAPIKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKey = "";
        if (value !== undefined)
            reflectionMergePartial<RotateAPIKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RotateAPIKeyRequest): RotateAPIKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_key */ 1:
                    message.apiKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RotateAPIKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_key = 1; */
        if (message.apiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.RotateAPIKeyRequest
 */
export const RotateAPIKeyRequest = new RotateAPIKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RotateAPIKeyResponse$Type extends MessageType<RotateAPIKeyResponse> {
    constructor() {
        super("service.RotateAPIKeyResponse", [
            { no: 1, name: "new_api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<RotateAPIKeyResponse>): RotateAPIKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newApiKey = "";
        if (value !== undefined)
            reflectionMergePartial<RotateAPIKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RotateAPIKeyResponse): RotateAPIKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string new_api_key */ 1:
                    message.newApiKey = reader.string();
                    break;
                case /* google.protobuf.Timestamp expires_at */ 2:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RotateAPIKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string new_api_key = 1; */
        if (message.newApiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.newApiKey);
        /* google.protobuf.Timestamp expires_at = 2; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.RotateAPIKeyResponse
 */
export const RotateAPIKeyResponse = new RotateAPIKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivateAPIKeyRequest$Type extends MessageType<ActivateAPIKeyRequest> {
    constructor() {
        super("service.ActivateAPIKeyRequest", [
            { no: 1, name: "api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActivateAPIKeyRequest>): ActivateAPIKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKey = "";
        if (value !== undefined)
            reflectionMergePartial<ActivateAPIKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivateAPIKeyRequest): ActivateAPIKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_key */ 1:
                    message.apiKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivateAPIKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_key = 1; */
        if (message.apiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ActivateAPIKeyRequest
 */
export const ActivateAPIKeyRequest = new ActivateAPIKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivateAPIKeyResponse$Type extends MessageType<ActivateAPIKeyResponse> {
    constructor() {
        super("service.ActivateAPIKeyResponse", []);
    }
    create(value?: PartialMessage<ActivateAPIKeyResponse>): ActivateAPIKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ActivateAPIKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivateAPIKeyResponse): ActivateAPIKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivateAPIKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ActivateAPIKeyResponse
 */
export const ActivateAPIKeyResponse = new ActivateAPIKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeactivateAPIKeyRequest$Type extends MessageType<DeactivateAPIKeyRequest> {
    constructor() {
        super("service.DeactivateAPIKeyRequest", [
            { no: 1, name: "api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deactivation_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeactivateAPIKeyRequest>): DeactivateAPIKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKey = "";
        message.deactivationMessage = "";
        if (value !== undefined)
            reflectionMergePartial<DeactivateAPIKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeactivateAPIKeyRequest): DeactivateAPIKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_key */ 1:
                    message.apiKey = reader.string();
                    break;
                case /* string deactivation_message */ 2:
                    message.deactivationMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeactivateAPIKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_key = 1; */
        if (message.apiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        /* string deactivation_message = 2; */
        if (message.deactivationMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.deactivationMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeactivateAPIKeyRequest
 */
export const DeactivateAPIKeyRequest = new DeactivateAPIKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeactivateAPIKeyResponse$Type extends MessageType<DeactivateAPIKeyResponse> {
    constructor() {
        super("service.DeactivateAPIKeyResponse", []);
    }
    create(value?: PartialMessage<DeactivateAPIKeyResponse>): DeactivateAPIKeyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeactivateAPIKeyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeactivateAPIKeyResponse): DeactivateAPIKeyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeactivateAPIKeyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DeactivateAPIKeyResponse
 */
export const DeactivateAPIKeyResponse = new DeactivateAPIKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAPIKeysRequest$Type extends MessageType<ListAPIKeysRequest> {
    constructor() {
        super("service.ListAPIKeysRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListAPIKeysRequest>): ListAPIKeysRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ListAPIKeysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAPIKeysRequest): ListAPIKeysRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAPIKeysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListAPIKeysRequest
 */
export const ListAPIKeysRequest = new ListAPIKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAPIKeysResponse$Type extends MessageType<ListAPIKeysResponse> {
    constructor() {
        super("service.ListAPIKeysResponse", [
            { no: 1, name: "api_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => APIKey }
        ]);
    }
    create(value?: PartialMessage<ListAPIKeysResponse>): ListAPIKeysResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKeys = [];
        if (value !== undefined)
            reflectionMergePartial<ListAPIKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListAPIKeysResponse): ListAPIKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.APIKey api_keys */ 1:
                    message.apiKeys.push(APIKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListAPIKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.APIKey api_keys = 1; */
        for (let i = 0; i < message.apiKeys.length; i++)
            APIKey.internalBinaryWrite(message.apiKeys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ListAPIKeysResponse
 */
export const ListAPIKeysResponse = new ListAPIKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APIKey$Type extends MessageType<APIKey> {
    constructor() {
        super("service.APIKey", [
            { no: 1, name: "api_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "role", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_service_key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "deactivation_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 8, name: "expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<APIKey>): APIKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiKey = "";
        message.userId = "";
        message.role = "";
        message.isServiceKey = false;
        message.isActive = false;
        message.deactivationMessage = "";
        if (value !== undefined)
            reflectionMergePartial<APIKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APIKey): APIKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string api_key */ 1:
                    message.apiKey = reader.string();
                    break;
                case /* string user_id */ 2:
                    message.userId = reader.string();
                    break;
                case /* string role */ 3:
                    message.role = reader.string();
                    break;
                case /* bool is_service_key */ 4:
                    message.isServiceKey = reader.bool();
                    break;
                case /* bool is_active */ 5:
                    message.isActive = reader.bool();
                    break;
                case /* string deactivation_message */ 6:
                    message.deactivationMessage = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 7:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp expires_at */ 8:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APIKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string api_key = 1; */
        if (message.apiKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.apiKey);
        /* string user_id = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string role = 3; */
        if (message.role !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.role);
        /* bool is_service_key = 4; */
        if (message.isServiceKey !== false)
            writer.tag(4, WireType.Varint).bool(message.isServiceKey);
        /* bool is_active = 5; */
        if (message.isActive !== false)
            writer.tag(5, WireType.Varint).bool(message.isActive);
        /* string deactivation_message = 6; */
        if (message.deactivationMessage !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.deactivationMessage);
        /* google.protobuf.Timestamp created_at = 7; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expires_at = 8; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.APIKey
 */
export const APIKey = new APIKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("service.ChangePasswordRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "old_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.oldPassword = "";
        message.newPassword = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string old_password */ 2:
                    message.oldPassword = reader.string();
                    break;
                case /* string new_password */ 3:
                    message.newPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string old_password = 2; */
        if (message.oldPassword !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oldPassword);
        /* string new_password = 3; */
        if (message.newPassword !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordResponse$Type extends MessageType<ChangePasswordResponse> {
    constructor() {
        super("service.ChangePasswordResponse", []);
    }
    create(value?: PartialMessage<ChangePasswordResponse>): ChangePasswordResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordResponse): ChangePasswordResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ChangePasswordResponse
 */
export const ChangePasswordResponse = new ChangePasswordResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("service.LoginRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("service.LoginResponse", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.firstName = "";
        message.lastName = "";
        message.isAdmin = false;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string first_name */ 2:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 3:
                    message.lastName = reader.string();
                    break;
                case /* bool is_admin */ 4:
                    message.isAdmin = reader.bool();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string first_name = 2; */
        if (message.firstName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 3; */
        if (message.lastName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.lastName);
        /* bool is_admin = 4; */
        if (message.isAdmin !== false)
            writer.tag(4, WireType.Varint).bool(message.isAdmin);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InviteUserRequest$Type extends MessageType<InviteUserRequest> {
    constructor() {
        super("service.InviteUserRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InviteUserRequest>): InviteUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<InviteUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InviteUserRequest): InviteUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 2:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InviteUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 2; */
        if (message.isAdmin !== false)
            writer.tag(2, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.InviteUserRequest
 */
export const InviteUserRequest = new InviteUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InviteUserResponse$Type extends MessageType<InviteUserResponse> {
    constructor() {
        super("service.InviteUserResponse", [
            { no: 1, name: "invitation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<InviteUserResponse>): InviteUserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.invitationId = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<InviteUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InviteUserResponse): InviteUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string invitation_id */ 1:
                    message.invitationId = reader.string();
                    break;
                case /* string token */ 2:
                    message.token = reader.string();
                    break;
                case /* google.protobuf.Timestamp expires_at */ 3:
                    message.expiresAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InviteUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string invitation_id = 1; */
        if (message.invitationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.invitationId);
        /* string token = 2; */
        if (message.token !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.token);
        /* google.protobuf.Timestamp expires_at = 3; */
        if (message.expiresAt)
            Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.InviteUserResponse
 */
export const InviteUserResponse = new InviteUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateInviteRequest$Type extends MessageType<ValidateInviteRequest> {
    constructor() {
        super("service.ValidateInviteRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateInviteRequest>): ValidateInviteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateInviteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateInviteRequest): ValidateInviteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateInviteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ValidateInviteRequest
 */
export const ValidateInviteRequest = new ValidateInviteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateInviteResponse$Type extends MessageType<ValidateInviteResponse> {
    constructor() {
        super("service.ValidateInviteResponse", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateInviteResponse>): ValidateInviteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateInviteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateInviteResponse): ValidateInviteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 2:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateInviteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 2; */
        if (message.isAdmin !== false)
            writer.tag(2, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ValidateInviteResponse
 */
export const ValidateInviteResponse = new ValidateInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanDomainRequest$Type extends MessageType<ScanDomainRequest> {
    constructor() {
        super("service.ScanDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanDomainRequest>): ScanDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<ScanDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanDomainRequest): ScanDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanDomainRequest
 */
export const ScanDomainRequest = new ScanDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanDomainResponse$Type extends MessageType<ScanDomainResponse> {
    constructor() {
        super("service.ScanDomainResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => DNSSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanDomainResponse>): ScanDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanDomainResponse): ScanDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.DNSSecurityResult result */ 2:
                    message.result = DNSSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.DNSSecurityResult result = 2; */
        if (message.result)
            DNSSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanDomainResponse
 */
export const ScanDomainResponse = new ScanDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDNSScanResultsByDomainRequest$Type extends MessageType<GetDNSScanResultsByDomainRequest> {
    constructor() {
        super("service.GetDNSScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDNSScanResultsByDomainRequest>): GetDNSScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetDNSScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDNSScanResultsByDomainRequest): GetDNSScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDNSScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetDNSScanResultsByDomainRequest
 */
export const GetDNSScanResultsByDomainRequest = new GetDNSScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDNSScanResultsByDomainResponse$Type extends MessageType<GetDNSScanResultsByDomainResponse> {
    constructor() {
        super("service.GetDNSScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DNSScanResult }
        ]);
    }
    create(value?: PartialMessage<GetDNSScanResultsByDomainResponse>): GetDNSScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetDNSScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDNSScanResultsByDomainResponse): GetDNSScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.DNSScanResult results */ 1:
                    message.results.push(DNSScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDNSScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.DNSScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            DNSScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetDNSScanResultsByDomainResponse
 */
export const GetDNSScanResultsByDomainResponse = new GetDNSScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDNSScanResultByIDRequest$Type extends MessageType<GetDNSScanResultByIDRequest> {
    constructor() {
        super("service.GetDNSScanResultByIDRequest", [
            { no: 1, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDNSScanResultByIDRequest>): GetDNSScanResultByIDRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<GetDNSScanResultByIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDNSScanResultByIDRequest): GetDNSScanResultByIDRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dns_scan_id */ 1:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDNSScanResultByIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dns_scan_id = 1; */
        if (message.dnsScanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetDNSScanResultByIDRequest
 */
export const GetDNSScanResultByIDRequest = new GetDNSScanResultByIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDNSScanResultByIDResponse$Type extends MessageType<GetDNSScanResultByIDResponse> {
    constructor() {
        super("service.GetDNSScanResultByIDResponse", [
            { no: 1, name: "result", kind: "message", T: () => DNSScanResult }
        ]);
    }
    create(value?: PartialMessage<GetDNSScanResultByIDResponse>): GetDNSScanResultByIDResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetDNSScanResultByIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDNSScanResultByIDResponse): GetDNSScanResultByIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* service.DNSScanResult result */ 1:
                    message.result = DNSScanResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDNSScanResultByIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* service.DNSScanResult result = 1; */
        if (message.result)
            DNSScanResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetDNSScanResultByIDResponse
 */
export const GetDNSScanResultByIDResponse = new GetDNSScanResultByIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNSScanResult$Type extends MessageType<DNSScanResult> {
    constructor() {
        super("service.DNSScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => DNSSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<DNSScanResult>): DNSScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<DNSScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNSScanResult): DNSScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.DNSSecurityResult result */ 4:
                    message.result = DNSSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNSScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.DNSSecurityResult result = 4; */
        if (message.result)
            DNSSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DNSScanResult
 */
export const DNSScanResult = new DNSScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanTLSRequest$Type extends MessageType<ScanTLSRequest> {
    constructor() {
        super("service.ScanTLSRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanTLSRequest>): ScanTLSRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanTLSRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanTLSRequest): ScanTLSRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanTLSRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanTLSRequest
 */
export const ScanTLSRequest = new ScanTLSRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanTLSResponse$Type extends MessageType<ScanTLSResponse> {
    constructor() {
        super("service.ScanTLSResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => TLSSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanTLSResponse>): ScanTLSResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanTLSResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanTLSResponse): ScanTLSResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.TLSSecurityResult result */ 2:
                    message.result = TLSSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanTLSResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.TLSSecurityResult result = 2; */
        if (message.result)
            TLSSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanTLSResponse
 */
export const ScanTLSResponse = new ScanTLSResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTLSScanResultsByDomainRequest$Type extends MessageType<GetTLSScanResultsByDomainRequest> {
    constructor() {
        super("service.GetTLSScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTLSScanResultsByDomainRequest>): GetTLSScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetTLSScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTLSScanResultsByDomainRequest): GetTLSScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTLSScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetTLSScanResultsByDomainRequest
 */
export const GetTLSScanResultsByDomainRequest = new GetTLSScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTLSScanResultsByDomainResponse$Type extends MessageType<GetTLSScanResultsByDomainResponse> {
    constructor() {
        super("service.GetTLSScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TLSScanResult }
        ]);
    }
    create(value?: PartialMessage<GetTLSScanResultsByDomainResponse>): GetTLSScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetTLSScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTLSScanResultsByDomainResponse): GetTLSScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.TLSScanResult results */ 1:
                    message.results.push(TLSScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTLSScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.TLSScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            TLSScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetTLSScanResultsByDomainResponse
 */
export const GetTLSScanResultsByDomainResponse = new GetTLSScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSScanResult$Type extends MessageType<TLSScanResult> {
    constructor() {
        super("service.TLSScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => TLSSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TLSScanResult>): TLSScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<TLSScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSScanResult): TLSScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.TLSSecurityResult result */ 4:
                    message.result = TLSSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.TLSSecurityResult result = 4; */
        if (message.result)
            TLSSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.TLSScanResult
 */
export const TLSScanResult = new TLSScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanCrtShRequest$Type extends MessageType<ScanCrtShRequest> {
    constructor() {
        super("service.ScanCrtShRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanCrtShRequest>): ScanCrtShRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanCrtShRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanCrtShRequest): ScanCrtShRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanCrtShRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanCrtShRequest
 */
export const ScanCrtShRequest = new ScanCrtShRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanCrtShResponse$Type extends MessageType<ScanCrtShResponse> {
    constructor() {
        super("service.ScanCrtShResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => CrtShSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanCrtShResponse>): ScanCrtShResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanCrtShResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanCrtShResponse): ScanCrtShResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.CrtShSecurityResult result */ 2:
                    message.result = CrtShSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanCrtShResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.CrtShSecurityResult result = 2; */
        if (message.result)
            CrtShSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanCrtShResponse
 */
export const ScanCrtShResponse = new ScanCrtShResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCrtShScanResultsByDomainRequest$Type extends MessageType<GetCrtShScanResultsByDomainRequest> {
    constructor() {
        super("service.GetCrtShScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCrtShScanResultsByDomainRequest>): GetCrtShScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetCrtShScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCrtShScanResultsByDomainRequest): GetCrtShScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCrtShScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetCrtShScanResultsByDomainRequest
 */
export const GetCrtShScanResultsByDomainRequest = new GetCrtShScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCrtShScanResultsByDomainResponse$Type extends MessageType<GetCrtShScanResultsByDomainResponse> {
    constructor() {
        super("service.GetCrtShScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CrtShScanResult }
        ]);
    }
    create(value?: PartialMessage<GetCrtShScanResultsByDomainResponse>): GetCrtShScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetCrtShScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCrtShScanResultsByDomainResponse): GetCrtShScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.CrtShScanResult results */ 1:
                    message.results.push(CrtShScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCrtShScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.CrtShScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            CrtShScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetCrtShScanResultsByDomainResponse
 */
export const GetCrtShScanResultsByDomainResponse = new GetCrtShScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrtShScanResult$Type extends MessageType<CrtShScanResult> {
    constructor() {
        super("service.CrtShScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => CrtShSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CrtShScanResult>): CrtShScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<CrtShScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrtShScanResult): CrtShScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.CrtShSecurityResult result */ 4:
                    message.result = CrtShSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrtShScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.CrtShSecurityResult result = 4; */
        if (message.result)
            CrtShSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CrtShScanResult
 */
export const CrtShScanResult = new CrtShScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanChaosRequest$Type extends MessageType<ScanChaosRequest> {
    constructor() {
        super("service.ScanChaosRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanChaosRequest>): ScanChaosRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanChaosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanChaosRequest): ScanChaosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanChaosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanChaosRequest
 */
export const ScanChaosRequest = new ScanChaosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanChaosResponse$Type extends MessageType<ScanChaosResponse> {
    constructor() {
        super("service.ScanChaosResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => ChaosSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanChaosResponse>): ScanChaosResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanChaosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanChaosResponse): ScanChaosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.ChaosSecurityResult result */ 2:
                    message.result = ChaosSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanChaosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.ChaosSecurityResult result = 2; */
        if (message.result)
            ChaosSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanChaosResponse
 */
export const ScanChaosResponse = new ScanChaosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChaosScanResultsByDomainRequest$Type extends MessageType<GetChaosScanResultsByDomainRequest> {
    constructor() {
        super("service.GetChaosScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetChaosScanResultsByDomainRequest>): GetChaosScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetChaosScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChaosScanResultsByDomainRequest): GetChaosScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChaosScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetChaosScanResultsByDomainRequest
 */
export const GetChaosScanResultsByDomainRequest = new GetChaosScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChaosScanResultsByDomainResponse$Type extends MessageType<GetChaosScanResultsByDomainResponse> {
    constructor() {
        super("service.GetChaosScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChaosScanResult }
        ]);
    }
    create(value?: PartialMessage<GetChaosScanResultsByDomainResponse>): GetChaosScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetChaosScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChaosScanResultsByDomainResponse): GetChaosScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.ChaosScanResult results */ 1:
                    message.results.push(ChaosScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChaosScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.ChaosScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            ChaosScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetChaosScanResultsByDomainResponse
 */
export const GetChaosScanResultsByDomainResponse = new GetChaosScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChaosScanResult$Type extends MessageType<ChaosScanResult> {
    constructor() {
        super("service.ChaosScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => ChaosSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ChaosScanResult>): ChaosScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ChaosScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChaosScanResult): ChaosScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.ChaosSecurityResult result */ 4:
                    message.result = ChaosSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChaosScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.ChaosSecurityResult result = 4; */
        if (message.result)
            ChaosSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ChaosScanResult
 */
export const ChaosScanResult = new ChaosScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanShodanRequest$Type extends MessageType<ScanShodanRequest> {
    constructor() {
        super("service.ScanShodanRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanShodanRequest>): ScanShodanRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanShodanRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanShodanRequest): ScanShodanRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanShodanRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanShodanRequest
 */
export const ScanShodanRequest = new ScanShodanRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanShodanResponse$Type extends MessageType<ScanShodanResponse> {
    constructor() {
        super("service.ScanShodanResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => ShodanSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanShodanResponse>): ScanShodanResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanShodanResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanShodanResponse): ScanShodanResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.ShodanSecurityResult result */ 2:
                    message.result = ShodanSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanShodanResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.ShodanSecurityResult result = 2; */
        if (message.result)
            ShodanSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanShodanResponse
 */
export const ScanShodanResponse = new ScanShodanResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShodanScanResultsByDomainRequest$Type extends MessageType<GetShodanScanResultsByDomainRequest> {
    constructor() {
        super("service.GetShodanScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetShodanScanResultsByDomainRequest>): GetShodanScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetShodanScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShodanScanResultsByDomainRequest): GetShodanScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShodanScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetShodanScanResultsByDomainRequest
 */
export const GetShodanScanResultsByDomainRequest = new GetShodanScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShodanScanResultsByDomainResponse$Type extends MessageType<GetShodanScanResultsByDomainResponse> {
    constructor() {
        super("service.GetShodanScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ShodanScanResult }
        ]);
    }
    create(value?: PartialMessage<GetShodanScanResultsByDomainResponse>): GetShodanScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetShodanScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShodanScanResultsByDomainResponse): GetShodanScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.ShodanScanResult results */ 1:
                    message.results.push(ShodanScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShodanScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.ShodanScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            ShodanScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetShodanScanResultsByDomainResponse
 */
export const GetShodanScanResultsByDomainResponse = new GetShodanScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DNSSecurityResult$Type extends MessageType<DNSSecurityResult> {
    constructor() {
        super("service.DNSSecurityResult", [
            { no: 1, name: "spf_record", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spf_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "spf_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dkim_record", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dkim_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "dkim_validation_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "dmarc_record", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "dmarc_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "dmarc_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "dmarc_validation_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "dnssec_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "dnssec_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "dnssec_validation_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "ip_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "mx_records", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "ns_records", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DNSSecurityResult>): DNSSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spfRecord = "";
        message.spfValid = false;
        message.spfPolicy = "";
        message.dkimRecord = "";
        message.dkimValid = false;
        message.dkimValidationError = "";
        message.dmarcRecord = "";
        message.dmarcPolicy = "";
        message.dmarcValid = false;
        message.dmarcValidationError = "";
        message.dnssecEnabled = false;
        message.dnssecValid = false;
        message.dnssecValidationError = "";
        message.ipAddresses = [];
        message.mxRecords = [];
        message.nsRecords = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<DNSSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DNSSecurityResult): DNSSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string spf_record */ 1:
                    message.spfRecord = reader.string();
                    break;
                case /* bool spf_valid */ 2:
                    message.spfValid = reader.bool();
                    break;
                case /* string spf_policy */ 3:
                    message.spfPolicy = reader.string();
                    break;
                case /* string dkim_record */ 4:
                    message.dkimRecord = reader.string();
                    break;
                case /* bool dkim_valid */ 5:
                    message.dkimValid = reader.bool();
                    break;
                case /* string dkim_validation_error */ 6:
                    message.dkimValidationError = reader.string();
                    break;
                case /* string dmarc_record */ 7:
                    message.dmarcRecord = reader.string();
                    break;
                case /* string dmarc_policy */ 8:
                    message.dmarcPolicy = reader.string();
                    break;
                case /* bool dmarc_valid */ 9:
                    message.dmarcValid = reader.bool();
                    break;
                case /* string dmarc_validation_error */ 10:
                    message.dmarcValidationError = reader.string();
                    break;
                case /* bool dnssec_enabled */ 11:
                    message.dnssecEnabled = reader.bool();
                    break;
                case /* bool dnssec_valid */ 12:
                    message.dnssecValid = reader.bool();
                    break;
                case /* string dnssec_validation_error */ 13:
                    message.dnssecValidationError = reader.string();
                    break;
                case /* repeated string ip_addresses */ 14:
                    message.ipAddresses.push(reader.string());
                    break;
                case /* repeated string mx_records */ 15:
                    message.mxRecords.push(reader.string());
                    break;
                case /* repeated string ns_records */ 16:
                    message.nsRecords.push(reader.string());
                    break;
                case /* repeated string errors */ 17:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DNSSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string spf_record = 1; */
        if (message.spfRecord !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.spfRecord);
        /* bool spf_valid = 2; */
        if (message.spfValid !== false)
            writer.tag(2, WireType.Varint).bool(message.spfValid);
        /* string spf_policy = 3; */
        if (message.spfPolicy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.spfPolicy);
        /* string dkim_record = 4; */
        if (message.dkimRecord !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dkimRecord);
        /* bool dkim_valid = 5; */
        if (message.dkimValid !== false)
            writer.tag(5, WireType.Varint).bool(message.dkimValid);
        /* string dkim_validation_error = 6; */
        if (message.dkimValidationError !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.dkimValidationError);
        /* string dmarc_record = 7; */
        if (message.dmarcRecord !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.dmarcRecord);
        /* string dmarc_policy = 8; */
        if (message.dmarcPolicy !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.dmarcPolicy);
        /* bool dmarc_valid = 9; */
        if (message.dmarcValid !== false)
            writer.tag(9, WireType.Varint).bool(message.dmarcValid);
        /* string dmarc_validation_error = 10; */
        if (message.dmarcValidationError !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.dmarcValidationError);
        /* bool dnssec_enabled = 11; */
        if (message.dnssecEnabled !== false)
            writer.tag(11, WireType.Varint).bool(message.dnssecEnabled);
        /* bool dnssec_valid = 12; */
        if (message.dnssecValid !== false)
            writer.tag(12, WireType.Varint).bool(message.dnssecValid);
        /* string dnssec_validation_error = 13; */
        if (message.dnssecValidationError !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.dnssecValidationError);
        /* repeated string ip_addresses = 14; */
        for (let i = 0; i < message.ipAddresses.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.ipAddresses[i]);
        /* repeated string mx_records = 15; */
        for (let i = 0; i < message.mxRecords.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.mxRecords[i]);
        /* repeated string ns_records = 16; */
        for (let i = 0; i < message.nsRecords.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.nsRecords[i]);
        /* repeated string errors = 17; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.DNSSecurityResult
 */
export const DNSSecurityResult = new DNSSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSSecurityResult$Type extends MessageType<TLSSecurityResult> {
    constructor() {
        super("service.TLSSecurityResult", [
            { no: 1, name: "tls_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cipher_suite", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hsts_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "certificate_valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "cert_issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "cert_subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "cert_not_before", kind: "message", T: () => Timestamp },
            { no: 8, name: "cert_not_after", kind: "message", T: () => Timestamp },
            { no: 9, name: "cert_dns_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "cert_key_strength", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "cert_signature_algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TLSSecurityResult>): TLSSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tlsVersion = "";
        message.cipherSuite = "";
        message.hstsHeader = false;
        message.certificateValid = false;
        message.certIssuer = "";
        message.certSubject = "";
        message.certDnsNames = [];
        message.certKeyStrength = 0;
        message.certSignatureAlgorithm = "";
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<TLSSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSSecurityResult): TLSSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tls_version */ 1:
                    message.tlsVersion = reader.string();
                    break;
                case /* string cipher_suite */ 2:
                    message.cipherSuite = reader.string();
                    break;
                case /* bool hsts_header */ 3:
                    message.hstsHeader = reader.bool();
                    break;
                case /* bool certificate_valid */ 4:
                    message.certificateValid = reader.bool();
                    break;
                case /* string cert_issuer */ 5:
                    message.certIssuer = reader.string();
                    break;
                case /* string cert_subject */ 6:
                    message.certSubject = reader.string();
                    break;
                case /* google.protobuf.Timestamp cert_not_before */ 7:
                    message.certNotBefore = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.certNotBefore);
                    break;
                case /* google.protobuf.Timestamp cert_not_after */ 8:
                    message.certNotAfter = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.certNotAfter);
                    break;
                case /* repeated string cert_dns_names */ 9:
                    message.certDnsNames.push(reader.string());
                    break;
                case /* int32 cert_key_strength */ 10:
                    message.certKeyStrength = reader.int32();
                    break;
                case /* string cert_signature_algorithm */ 11:
                    message.certSignatureAlgorithm = reader.string();
                    break;
                case /* repeated string errors */ 12:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tls_version = 1; */
        if (message.tlsVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tlsVersion);
        /* string cipher_suite = 2; */
        if (message.cipherSuite !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cipherSuite);
        /* bool hsts_header = 3; */
        if (message.hstsHeader !== false)
            writer.tag(3, WireType.Varint).bool(message.hstsHeader);
        /* bool certificate_valid = 4; */
        if (message.certificateValid !== false)
            writer.tag(4, WireType.Varint).bool(message.certificateValid);
        /* string cert_issuer = 5; */
        if (message.certIssuer !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.certIssuer);
        /* string cert_subject = 6; */
        if (message.certSubject !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.certSubject);
        /* google.protobuf.Timestamp cert_not_before = 7; */
        if (message.certNotBefore)
            Timestamp.internalBinaryWrite(message.certNotBefore, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp cert_not_after = 8; */
        if (message.certNotAfter)
            Timestamp.internalBinaryWrite(message.certNotAfter, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cert_dns_names = 9; */
        for (let i = 0; i < message.certDnsNames.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.certDnsNames[i]);
        /* int32 cert_key_strength = 10; */
        if (message.certKeyStrength !== 0)
            writer.tag(10, WireType.Varint).int32(message.certKeyStrength);
        /* string cert_signature_algorithm = 11; */
        if (message.certSignatureAlgorithm !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.certSignatureAlgorithm);
        /* repeated string errors = 12; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.TLSSecurityResult
 */
export const TLSSecurityResult = new TLSSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrtShCertificate$Type extends MessageType<CrtShCertificate> {
    constructor() {
        super("service.CrtShCertificate", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "common_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "not_before", kind: "message", T: () => Timestamp },
            { no: 5, name: "not_after", kind: "message", T: () => Timestamp },
            { no: 6, name: "serial_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "dns_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "signature_algorithm", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CrtShCertificate>): CrtShCertificate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.commonName = "";
        message.issuer = "";
        message.serialNumber = "";
        message.dnsNames = [];
        message.signatureAlgorithm = "";
        if (value !== undefined)
            reflectionMergePartial<CrtShCertificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrtShCertificate): CrtShCertificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string common_name */ 2:
                    message.commonName = reader.string();
                    break;
                case /* string issuer */ 3:
                    message.issuer = reader.string();
                    break;
                case /* google.protobuf.Timestamp not_before */ 4:
                    message.notBefore = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.notBefore);
                    break;
                case /* google.protobuf.Timestamp not_after */ 5:
                    message.notAfter = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.notAfter);
                    break;
                case /* string serial_number */ 6:
                    message.serialNumber = reader.string();
                    break;
                case /* repeated string dns_names */ 7:
                    message.dnsNames.push(reader.string());
                    break;
                case /* string signature_algorithm */ 8:
                    message.signatureAlgorithm = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrtShCertificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string common_name = 2; */
        if (message.commonName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commonName);
        /* string issuer = 3; */
        if (message.issuer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.issuer);
        /* google.protobuf.Timestamp not_before = 4; */
        if (message.notBefore)
            Timestamp.internalBinaryWrite(message.notBefore, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp not_after = 5; */
        if (message.notAfter)
            Timestamp.internalBinaryWrite(message.notAfter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string serial_number = 6; */
        if (message.serialNumber !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.serialNumber);
        /* repeated string dns_names = 7; */
        for (let i = 0; i < message.dnsNames.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.dnsNames[i]);
        /* string signature_algorithm = 8; */
        if (message.signatureAlgorithm !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.signatureAlgorithm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CrtShCertificate
 */
export const CrtShCertificate = new CrtShCertificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrtShSecurityResult$Type extends MessageType<CrtShSecurityResult> {
    constructor() {
        super("service.CrtShSecurityResult", [
            { no: 1, name: "certificates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CrtShCertificate },
            { no: 2, name: "subdomains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CrtShSecurityResult>): CrtShSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.certificates = [];
        message.subdomains = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<CrtShSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrtShSecurityResult): CrtShSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.CrtShCertificate certificates */ 1:
                    message.certificates.push(CrtShCertificate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string subdomains */ 2:
                    message.subdomains.push(reader.string());
                    break;
                case /* repeated string errors */ 3:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrtShSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.CrtShCertificate certificates = 1; */
        for (let i = 0; i < message.certificates.length; i++)
            CrtShCertificate.internalBinaryWrite(message.certificates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string subdomains = 2; */
        for (let i = 0; i < message.subdomains.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.subdomains[i]);
        /* repeated string errors = 3; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.CrtShSecurityResult
 */
export const CrtShSecurityResult = new CrtShSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChaosSecurityResult$Type extends MessageType<ChaosSecurityResult> {
    constructor() {
        super("service.ChaosSecurityResult", [
            { no: 1, name: "subdomains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChaosSecurityResult>): ChaosSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subdomains = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ChaosSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChaosSecurityResult): ChaosSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subdomains */ 1:
                    message.subdomains.push(reader.string());
                    break;
                case /* repeated string errors */ 2:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChaosSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subdomains = 1; */
        for (let i = 0; i < message.subdomains.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subdomains[i]);
        /* repeated string errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ChaosSecurityResult
 */
export const ChaosSecurityResult = new ChaosSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanScanResult$Type extends MessageType<ShodanScanResult> {
    constructor() {
        super("service.ShodanScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => ShodanSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ShodanScanResult>): ShodanScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ShodanScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanScanResult): ShodanScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.ShodanSecurityResult result */ 4:
                    message.result = ShodanSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.ShodanSecurityResult result = 4; */
        if (message.result)
            ShodanSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanScanResult
 */
export const ShodanScanResult = new ShodanScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanLocation$Type extends MessageType<ShodanLocation> {
    constructor() {
        super("service.ShodanLocation", [
            { no: 1, name: "city", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "country_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "latitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "longitude", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ShodanLocation>): ShodanLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.city = "";
        message.countryName = "";
        message.latitude = 0;
        message.longitude = 0;
        if (value !== undefined)
            reflectionMergePartial<ShodanLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanLocation): ShodanLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string city */ 1:
                    message.city = reader.string();
                    break;
                case /* string country_name */ 2:
                    message.countryName = reader.string();
                    break;
                case /* float latitude */ 3:
                    message.latitude = reader.float();
                    break;
                case /* float longitude */ 4:
                    message.longitude = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string city = 1; */
        if (message.city !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.city);
        /* string country_name = 2; */
        if (message.countryName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.countryName);
        /* float latitude = 3; */
        if (message.latitude !== 0)
            writer.tag(3, WireType.Bit32).float(message.latitude);
        /* float longitude = 4; */
        if (message.longitude !== 0)
            writer.tag(4, WireType.Bit32).float(message.longitude);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanLocation
 */
export const ShodanLocation = new ShodanLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanSSL$Type extends MessageType<ShodanSSL> {
    constructor() {
        super("service.ShodanSSL", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires", kind: "message", T: () => Timestamp },
            { no: 4, name: "not_after", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ShodanSSL>): ShodanSSL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.issuer = "";
        message.subject = "";
        if (value !== undefined)
            reflectionMergePartial<ShodanSSL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanSSL): ShodanSSL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* string subject */ 2:
                    message.subject = reader.string();
                    break;
                case /* google.protobuf.Timestamp expires */ 3:
                    message.expires = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expires);
                    break;
                case /* google.protobuf.Timestamp not_after */ 4:
                    message.notAfter = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.notAfter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanSSL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* string subject = 2; */
        if (message.subject !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subject);
        /* google.protobuf.Timestamp expires = 3; */
        if (message.expires)
            Timestamp.internalBinaryWrite(message.expires, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp not_after = 4; */
        if (message.notAfter)
            Timestamp.internalBinaryWrite(message.notAfter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanSSL
 */
export const ShodanSSL = new ShodanSSL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanMetadata$Type extends MessageType<ShodanMetadata> {
    constructor() {
        super("service.ShodanMetadata", [
            { no: 1, name: "module", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShodanMetadata>): ShodanMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.module = "";
        if (value !== undefined)
            reflectionMergePartial<ShodanMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanMetadata): ShodanMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string module */ 1:
                    message.module = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string module = 1; */
        if (message.module !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.module);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanMetadata
 */
export const ShodanMetadata = new ShodanMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanHost$Type extends MessageType<ShodanHost> {
    constructor() {
        super("service.ShodanHost", [
            { no: 1, name: "ip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hostnames", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "os", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "banner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "location", kind: "message", T: () => ShodanLocation },
            { no: 8, name: "ssl", kind: "message", T: () => ShodanSSL },
            { no: 9, name: "domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "asn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "org", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "isp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 14, name: "shodan_meta", kind: "message", T: () => ShodanMetadata }
        ]);
    }
    create(value?: PartialMessage<ShodanHost>): ShodanHost {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ip = "";
        message.port = 0;
        message.hostnames = [];
        message.os = "";
        message.banner = "";
        message.tags = [];
        message.domains = [];
        message.asn = "";
        message.org = "";
        message.isp = "";
        if (value !== undefined)
            reflectionMergePartial<ShodanHost>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanHost): ShodanHost {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ip */ 1:
                    message.ip = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                case /* repeated string hostnames */ 3:
                    message.hostnames.push(reader.string());
                    break;
                case /* string os */ 4:
                    message.os = reader.string();
                    break;
                case /* string banner */ 5:
                    message.banner = reader.string();
                    break;
                case /* repeated string tags */ 6:
                    message.tags.push(reader.string());
                    break;
                case /* service.ShodanLocation location */ 7:
                    message.location = ShodanLocation.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* service.ShodanSSL ssl */ 8:
                    message.ssl = ShodanSSL.internalBinaryRead(reader, reader.uint32(), options, message.ssl);
                    break;
                case /* repeated string domains */ 9:
                    message.domains.push(reader.string());
                    break;
                case /* string asn */ 10:
                    message.asn = reader.string();
                    break;
                case /* string org */ 11:
                    message.org = reader.string();
                    break;
                case /* string isp */ 12:
                    message.isp = reader.string();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 13:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* service.ShodanMetadata shodan_meta */ 14:
                    message.shodanMeta = ShodanMetadata.internalBinaryRead(reader, reader.uint32(), options, message.shodanMeta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanHost, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ip = 1; */
        if (message.ip !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ip);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        /* repeated string hostnames = 3; */
        for (let i = 0; i < message.hostnames.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.hostnames[i]);
        /* string os = 4; */
        if (message.os !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.os);
        /* string banner = 5; */
        if (message.banner !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.banner);
        /* repeated string tags = 6; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.tags[i]);
        /* service.ShodanLocation location = 7; */
        if (message.location)
            ShodanLocation.internalBinaryWrite(message.location, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* service.ShodanSSL ssl = 8; */
        if (message.ssl)
            ShodanSSL.internalBinaryWrite(message.ssl, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string domains = 9; */
        for (let i = 0; i < message.domains.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.domains[i]);
        /* string asn = 10; */
        if (message.asn !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.asn);
        /* string org = 11; */
        if (message.org !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.org);
        /* string isp = 12; */
        if (message.isp !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.isp);
        /* google.protobuf.Timestamp timestamp = 13; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* service.ShodanMetadata shodan_meta = 14; */
        if (message.shodanMeta)
            ShodanMetadata.internalBinaryWrite(message.shodanMeta, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanHost
 */
export const ShodanHost = new ShodanHost$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShodanSecurityResult$Type extends MessageType<ShodanSecurityResult> {
    constructor() {
        super("service.ShodanSecurityResult", [
            { no: 1, name: "hosts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ShodanHost },
            { no: 2, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShodanSecurityResult>): ShodanSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hosts = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ShodanSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShodanSecurityResult): ShodanSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.ShodanHost hosts */ 1:
                    message.hosts.push(ShodanHost.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string errors */ 2:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShodanSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.ShodanHost hosts = 1; */
        for (let i = 0; i < message.hosts.length; i++)
            ShodanHost.internalBinaryWrite(message.hosts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ShodanSecurityResult
 */
export const ShodanSecurityResult = new ShodanSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanOTXRequest$Type extends MessageType<ScanOTXRequest> {
    constructor() {
        super("service.ScanOTXRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanOTXRequest>): ScanOTXRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanOTXRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanOTXRequest): ScanOTXRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanOTXRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanOTXRequest
 */
export const ScanOTXRequest = new ScanOTXRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanOTXResponse$Type extends MessageType<ScanOTXResponse> {
    constructor() {
        super("service.ScanOTXResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => OTXSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanOTXResponse>): ScanOTXResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanOTXResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanOTXResponse): ScanOTXResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.OTXSecurityResult result */ 2:
                    message.result = OTXSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanOTXResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.OTXSecurityResult result = 2; */
        if (message.result)
            OTXSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanOTXResponse
 */
export const ScanOTXResponse = new ScanOTXResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOTXScanResultsByDomainRequest$Type extends MessageType<GetOTXScanResultsByDomainRequest> {
    constructor() {
        super("service.GetOTXScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOTXScanResultsByDomainRequest>): GetOTXScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetOTXScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOTXScanResultsByDomainRequest): GetOTXScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOTXScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetOTXScanResultsByDomainRequest
 */
export const GetOTXScanResultsByDomainRequest = new GetOTXScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOTXScanResultsByDomainResponse$Type extends MessageType<GetOTXScanResultsByDomainResponse> {
    constructor() {
        super("service.GetOTXScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OTXScanResult }
        ]);
    }
    create(value?: PartialMessage<GetOTXScanResultsByDomainResponse>): GetOTXScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetOTXScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOTXScanResultsByDomainResponse): GetOTXScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.OTXScanResult results */ 1:
                    message.results.push(OTXScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOTXScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.OTXScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            OTXScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetOTXScanResultsByDomainResponse
 */
export const GetOTXScanResultsByDomainResponse = new GetOTXScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXScanResult$Type extends MessageType<OTXScanResult> {
    constructor() {
        super("service.OTXScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => OTXSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<OTXScanResult>): OTXScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<OTXScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXScanResult): OTXScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.OTXSecurityResult result */ 4:
                    message.result = OTXSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.OTXSecurityResult result = 4; */
        if (message.result)
            OTXSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXScanResult
 */
export const OTXScanResult = new OTXScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXGeneralInfo$Type extends MessageType<OTXGeneralInfo> {
    constructor() {
        super("service.OTXGeneralInfo", [
            { no: 1, name: "pulse_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pulses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OTXGeneralInfo>): OTXGeneralInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pulseCount = 0;
        message.pulses = [];
        if (value !== undefined)
            reflectionMergePartial<OTXGeneralInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXGeneralInfo): OTXGeneralInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pulse_count */ 1:
                    message.pulseCount = reader.int32();
                    break;
                case /* repeated string pulses */ 2:
                    message.pulses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXGeneralInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pulse_count = 1; */
        if (message.pulseCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.pulseCount);
        /* repeated string pulses = 2; */
        for (let i = 0; i < message.pulses.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.pulses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXGeneralInfo
 */
export const OTXGeneralInfo = new OTXGeneralInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXMalware$Type extends MessageType<OTXMalware> {
    constructor() {
        super("service.OTXMalware", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "datetime", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<OTXMalware>): OTXMalware {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hash = "";
        if (value !== undefined)
            reflectionMergePartial<OTXMalware>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXMalware): OTXMalware {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* google.protobuf.Timestamp datetime */ 2:
                    message.datetime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.datetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXMalware, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* google.protobuf.Timestamp datetime = 2; */
        if (message.datetime)
            Timestamp.internalBinaryWrite(message.datetime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXMalware
 */
export const OTXMalware = new OTXMalware$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXURL$Type extends MessageType<OTXURL> {
    constructor() {
        super("service.OTXURL", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "datetime", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<OTXURL>): OTXURL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<OTXURL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXURL): OTXURL {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* google.protobuf.Timestamp datetime */ 2:
                    message.datetime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.datetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXURL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* google.protobuf.Timestamp datetime = 2; */
        if (message.datetime)
            Timestamp.internalBinaryWrite(message.datetime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXURL
 */
export const OTXURL = new OTXURL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXPassiveDNS$Type extends MessageType<OTXPassiveDNS> {
    constructor() {
        super("service.OTXPassiveDNS", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "record", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "datetime", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<OTXPassiveDNS>): OTXPassiveDNS {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.hostname = "";
        message.record = "";
        if (value !== undefined)
            reflectionMergePartial<OTXPassiveDNS>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXPassiveDNS): OTXPassiveDNS {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string record */ 3:
                    message.record = reader.string();
                    break;
                case /* google.protobuf.Timestamp datetime */ 4:
                    message.datetime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.datetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXPassiveDNS, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string record = 3; */
        if (message.record !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.record);
        /* google.protobuf.Timestamp datetime = 4; */
        if (message.datetime)
            Timestamp.internalBinaryWrite(message.datetime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXPassiveDNS
 */
export const OTXPassiveDNS = new OTXPassiveDNS$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OTXSecurityResult$Type extends MessageType<OTXSecurityResult> {
    constructor() {
        super("service.OTXSecurityResult", [
            { no: 1, name: "general_info", kind: "message", T: () => OTXGeneralInfo },
            { no: 2, name: "malware", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OTXMalware },
            { no: 3, name: "urls", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OTXURL },
            { no: 4, name: "passive_dns", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OTXPassiveDNS },
            { no: 5, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OTXSecurityResult>): OTXSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.malware = [];
        message.urls = [];
        message.passiveDns = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<OTXSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OTXSecurityResult): OTXSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* service.OTXGeneralInfo general_info */ 1:
                    message.generalInfo = OTXGeneralInfo.internalBinaryRead(reader, reader.uint32(), options, message.generalInfo);
                    break;
                case /* repeated service.OTXMalware malware */ 2:
                    message.malware.push(OTXMalware.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated service.OTXURL urls */ 3:
                    message.urls.push(OTXURL.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated service.OTXPassiveDNS passive_dns */ 4:
                    message.passiveDns.push(OTXPassiveDNS.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string errors */ 5:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OTXSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* service.OTXGeneralInfo general_info = 1; */
        if (message.generalInfo)
            OTXGeneralInfo.internalBinaryWrite(message.generalInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated service.OTXMalware malware = 2; */
        for (let i = 0; i < message.malware.length; i++)
            OTXMalware.internalBinaryWrite(message.malware[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated service.OTXURL urls = 3; */
        for (let i = 0; i < message.urls.length; i++)
            OTXURL.internalBinaryWrite(message.urls[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated service.OTXPassiveDNS passive_dns = 4; */
        for (let i = 0; i < message.passiveDns.length; i++)
            OTXPassiveDNS.internalBinaryWrite(message.passiveDns[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string errors = 5; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.OTXSecurityResult
 */
export const OTXSecurityResult = new OTXSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanWhoisRequest$Type extends MessageType<ScanWhoisRequest> {
    constructor() {
        super("service.ScanWhoisRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanWhoisRequest>): ScanWhoisRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanWhoisRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanWhoisRequest): ScanWhoisRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanWhoisRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanWhoisRequest
 */
export const ScanWhoisRequest = new ScanWhoisRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanWhoisResponse$Type extends MessageType<ScanWhoisResponse> {
    constructor() {
        super("service.ScanWhoisResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => WhoisSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanWhoisResponse>): ScanWhoisResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanWhoisResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanWhoisResponse): ScanWhoisResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.WhoisSecurityResult result */ 2:
                    message.result = WhoisSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanWhoisResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.WhoisSecurityResult result = 2; */
        if (message.result)
            WhoisSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanWhoisResponse
 */
export const ScanWhoisResponse = new ScanWhoisResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWhoisScanResultsByDomainRequest$Type extends MessageType<GetWhoisScanResultsByDomainRequest> {
    constructor() {
        super("service.GetWhoisScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWhoisScanResultsByDomainRequest>): GetWhoisScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetWhoisScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWhoisScanResultsByDomainRequest): GetWhoisScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWhoisScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetWhoisScanResultsByDomainRequest
 */
export const GetWhoisScanResultsByDomainRequest = new GetWhoisScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWhoisScanResultsByDomainResponse$Type extends MessageType<GetWhoisScanResultsByDomainResponse> {
    constructor() {
        super("service.GetWhoisScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WhoisScanResult }
        ]);
    }
    create(value?: PartialMessage<GetWhoisScanResultsByDomainResponse>): GetWhoisScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetWhoisScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWhoisScanResultsByDomainResponse): GetWhoisScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.WhoisScanResult results */ 1:
                    message.results.push(WhoisScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWhoisScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.WhoisScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            WhoisScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetWhoisScanResultsByDomainResponse
 */
export const GetWhoisScanResultsByDomainResponse = new GetWhoisScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WhoisScanResult$Type extends MessageType<WhoisScanResult> {
    constructor() {
        super("service.WhoisScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => WhoisSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<WhoisScanResult>): WhoisScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<WhoisScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WhoisScanResult): WhoisScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.WhoisSecurityResult result */ 4:
                    message.result = WhoisSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WhoisScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.WhoisSecurityResult result = 4; */
        if (message.result)
            WhoisSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.WhoisScanResult
 */
export const WhoisScanResult = new WhoisScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WhoisSecurityResult$Type extends MessageType<WhoisSecurityResult> {
    constructor() {
        super("service.WhoisSecurityResult", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "registrar", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "creation_date", kind: "message", T: () => Timestamp },
            { no: 4, name: "expiry_date", kind: "message", T: () => Timestamp },
            { no: 5, name: "registrant_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WhoisSecurityResult>): WhoisSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.registrar = "";
        message.registrantName = "";
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<WhoisSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WhoisSecurityResult): WhoisSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string registrar */ 2:
                    message.registrar = reader.string();
                    break;
                case /* google.protobuf.Timestamp creation_date */ 3:
                    message.creationDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.creationDate);
                    break;
                case /* google.protobuf.Timestamp expiry_date */ 4:
                    message.expiryDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiryDate);
                    break;
                case /* string registrant_name */ 5:
                    message.registrantName = reader.string();
                    break;
                case /* repeated string errors */ 6:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WhoisSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string registrar = 2; */
        if (message.registrar !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.registrar);
        /* google.protobuf.Timestamp creation_date = 3; */
        if (message.creationDate)
            Timestamp.internalBinaryWrite(message.creationDate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expiry_date = 4; */
        if (message.expiryDate)
            Timestamp.internalBinaryWrite(message.expiryDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string registrant_name = 5; */
        if (message.registrantName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.registrantName);
        /* repeated string errors = 6; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.WhoisSecurityResult
 */
export const WhoisSecurityResult = new WhoisSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbuseChIOC$Type extends MessageType<AbuseChIOC> {
    constructor() {
        super("service.AbuseChIOC", [
            { no: 1, name: "ioc_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ioc_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "threat_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "confidence", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "first_seen", kind: "message", T: () => Timestamp },
            { no: 6, name: "last_seen", kind: "message", T: () => Timestamp },
            { no: 7, name: "malware_alias", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AbuseChIOC>): AbuseChIOC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iocType = "";
        message.iocValue = "";
        message.threatType = "";
        message.confidence = 0;
        message.malwareAlias = [];
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<AbuseChIOC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbuseChIOC): AbuseChIOC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ioc_type */ 1:
                    message.iocType = reader.string();
                    break;
                case /* string ioc_value */ 2:
                    message.iocValue = reader.string();
                    break;
                case /* string threat_type */ 3:
                    message.threatType = reader.string();
                    break;
                case /* float confidence */ 4:
                    message.confidence = reader.float();
                    break;
                case /* google.protobuf.Timestamp first_seen */ 5:
                    message.firstSeen = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.firstSeen);
                    break;
                case /* google.protobuf.Timestamp last_seen */ 6:
                    message.lastSeen = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastSeen);
                    break;
                case /* repeated string malware_alias */ 7:
                    message.malwareAlias.push(reader.string());
                    break;
                case /* repeated string tags */ 8:
                    message.tags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbuseChIOC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ioc_type = 1; */
        if (message.iocType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iocType);
        /* string ioc_value = 2; */
        if (message.iocValue !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.iocValue);
        /* string threat_type = 3; */
        if (message.threatType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.threatType);
        /* float confidence = 4; */
        if (message.confidence !== 0)
            writer.tag(4, WireType.Bit32).float(message.confidence);
        /* google.protobuf.Timestamp first_seen = 5; */
        if (message.firstSeen)
            Timestamp.internalBinaryWrite(message.firstSeen, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_seen = 6; */
        if (message.lastSeen)
            Timestamp.internalBinaryWrite(message.lastSeen, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string malware_alias = 7; */
        for (let i = 0; i < message.malwareAlias.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.malwareAlias[i]);
        /* repeated string tags = 8; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.tags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.AbuseChIOC
 */
export const AbuseChIOC = new AbuseChIOC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbuseChSecurityResult$Type extends MessageType<AbuseChSecurityResult> {
    constructor() {
        super("service.AbuseChSecurityResult", [
            { no: 1, name: "iocs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AbuseChIOC },
            { no: 2, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AbuseChSecurityResult>): AbuseChSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iocs = [];
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<AbuseChSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbuseChSecurityResult): AbuseChSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.AbuseChIOC iocs */ 1:
                    message.iocs.push(AbuseChIOC.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string errors */ 2:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbuseChSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.AbuseChIOC iocs = 1; */
        for (let i = 0; i < message.iocs.length; i++)
            AbuseChIOC.internalBinaryWrite(message.iocs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string errors = 2; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.AbuseChSecurityResult
 */
export const AbuseChSecurityResult = new AbuseChSecurityResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanAbuseChRequest$Type extends MessageType<ScanAbuseChRequest> {
    constructor() {
        super("service.ScanAbuseChRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanAbuseChRequest>): ScanAbuseChRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanAbuseChRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanAbuseChRequest): ScanAbuseChRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanAbuseChRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanAbuseChRequest
 */
export const ScanAbuseChRequest = new ScanAbuseChRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanAbuseChResponse$Type extends MessageType<ScanAbuseChResponse> {
    constructor() {
        super("service.ScanAbuseChResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => AbuseChSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanAbuseChResponse>): ScanAbuseChResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanAbuseChResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanAbuseChResponse): ScanAbuseChResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.AbuseChSecurityResult result */ 2:
                    message.result = AbuseChSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanAbuseChResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.AbuseChSecurityResult result = 2; */
        if (message.result)
            AbuseChSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanAbuseChResponse
 */
export const ScanAbuseChResponse = new ScanAbuseChResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAbuseChScanResultsByDomainRequest$Type extends MessageType<GetAbuseChScanResultsByDomainRequest> {
    constructor() {
        super("service.GetAbuseChScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAbuseChScanResultsByDomainRequest>): GetAbuseChScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetAbuseChScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAbuseChScanResultsByDomainRequest): GetAbuseChScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAbuseChScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetAbuseChScanResultsByDomainRequest
 */
export const GetAbuseChScanResultsByDomainRequest = new GetAbuseChScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAbuseChScanResultsByDomainResponse$Type extends MessageType<GetAbuseChScanResultsByDomainResponse> {
    constructor() {
        super("service.GetAbuseChScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AbuseChScanResult }
        ]);
    }
    create(value?: PartialMessage<GetAbuseChScanResultsByDomainResponse>): GetAbuseChScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetAbuseChScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAbuseChScanResultsByDomainResponse): GetAbuseChScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.AbuseChScanResult results */ 1:
                    message.results.push(AbuseChScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAbuseChScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.AbuseChScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            AbuseChScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetAbuseChScanResultsByDomainResponse
 */
export const GetAbuseChScanResultsByDomainResponse = new GetAbuseChScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbuseChScanResult$Type extends MessageType<AbuseChScanResult> {
    constructor() {
        super("service.AbuseChScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => AbuseChSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<AbuseChScanResult>): AbuseChScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<AbuseChScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbuseChScanResult): AbuseChScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.AbuseChSecurityResult result */ 4:
                    message.result = AbuseChSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbuseChScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.AbuseChSecurityResult result = 4; */
        if (message.result)
            AbuseChSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.AbuseChScanResult
 */
export const AbuseChScanResult = new AbuseChScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanISCRequest$Type extends MessageType<ScanISCRequest> {
    constructor() {
        super("service.ScanISCRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScanISCRequest>): ScanISCRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanISCRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanISCRequest): ScanISCRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 2:
                    message.dnsScanId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanISCRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 2; */
        if (message.dnsScanId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dnsScanId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanISCRequest
 */
export const ScanISCRequest = new ScanISCRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScanISCResponse$Type extends MessageType<ScanISCResponse> {
    constructor() {
        super("service.ScanISCResponse", [
            { no: 1, name: "scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "result", kind: "message", T: () => ISCSecurityResult }
        ]);
    }
    create(value?: PartialMessage<ScanISCResponse>): ScanISCResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scanId = "";
        if (value !== undefined)
            reflectionMergePartial<ScanISCResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScanISCResponse): ScanISCResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string scan_id */ 1:
                    message.scanId = reader.string();
                    break;
                case /* service.ISCSecurityResult result */ 2:
                    message.result = ISCSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScanISCResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string scan_id = 1; */
        if (message.scanId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.scanId);
        /* service.ISCSecurityResult result = 2; */
        if (message.result)
            ISCSecurityResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ScanISCResponse
 */
export const ScanISCResponse = new ScanISCResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetISCScanResultsByDomainRequest$Type extends MessageType<GetISCScanResultsByDomainRequest> {
    constructor() {
        super("service.GetISCScanResultsByDomainRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetISCScanResultsByDomainRequest>): GetISCScanResultsByDomainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<GetISCScanResultsByDomainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetISCScanResultsByDomainRequest): GetISCScanResultsByDomainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetISCScanResultsByDomainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetISCScanResultsByDomainRequest
 */
export const GetISCScanResultsByDomainRequest = new GetISCScanResultsByDomainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetISCScanResultsByDomainResponse$Type extends MessageType<GetISCScanResultsByDomainResponse> {
    constructor() {
        super("service.GetISCScanResultsByDomainResponse", [
            { no: 1, name: "results", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ISCScanResult }
        ]);
    }
    create(value?: PartialMessage<GetISCScanResultsByDomainResponse>): GetISCScanResultsByDomainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<GetISCScanResultsByDomainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetISCScanResultsByDomainResponse): GetISCScanResultsByDomainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.ISCScanResult results */ 1:
                    message.results.push(ISCScanResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetISCScanResultsByDomainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.ISCScanResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            ISCScanResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.GetISCScanResultsByDomainResponse
 */
export const GetISCScanResultsByDomainResponse = new GetISCScanResultsByDomainResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ISCScanResult$Type extends MessageType<ISCScanResult> {
    constructor() {
        super("service.ISCScanResult", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dns_scan_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "result", kind: "message", T: () => ISCSecurityResult },
            { no: 5, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ISCScanResult>): ISCScanResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.domain = "";
        message.dnsScanId = "";
        if (value !== undefined)
            reflectionMergePartial<ISCScanResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ISCScanResult): ISCScanResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* string dns_scan_id */ 3:
                    message.dnsScanId = reader.string();
                    break;
                case /* service.ISCSecurityResult result */ 4:
                    message.result = ISCSecurityResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* google.protobuf.Timestamp created_at */ 5:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ISCScanResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* string dns_scan_id = 3; */
        if (message.dnsScanId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.dnsScanId);
        /* service.ISCSecurityResult result = 4; */
        if (message.result)
            ISCSecurityResult.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 5; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ISCScanResult
 */
export const ISCScanResult = new ISCScanResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ISCIncident$Type extends MessageType<ISCIncident> {
    constructor() {
        super("service.ISCIncident", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date", kind: "message", T: () => Timestamp },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "severity", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ISCIncident>): ISCIncident {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.description = "";
        message.severity = "";
        if (value !== undefined)
            reflectionMergePartial<ISCIncident>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ISCIncident): ISCIncident {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* google.protobuf.Timestamp date */ 2:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string severity */ 4:
                    message.severity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ISCIncident, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* google.protobuf.Timestamp date = 2; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string severity = 4; */
        if (message.severity !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.severity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ISCIncident
 */
export const ISCIncident = new ISCIncident$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ISCSecurityResult$Type extends MessageType<ISCSecurityResult> {
    constructor() {
        super("service.ISCSecurityResult", [
            { no: 1, name: "incidents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ISCIncident },
            { no: 2, name: "overall_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "errors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ISCSecurityResult>): ISCSecurityResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.incidents = [];
        message.overallRisk = "";
        message.errors = [];
        if (value !== undefined)
            reflectionMergePartial<ISCSecurityResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ISCSecurityResult): ISCSecurityResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated service.ISCIncident incidents */ 1:
                    message.incidents.push(ISCIncident.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string overall_risk */ 2:
                    message.overallRisk = reader.string();
                    break;
                case /* repeated string errors */ 3:
                    message.errors.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ISCSecurityResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated service.ISCIncident incidents = 1; */
        for (let i = 0; i < message.incidents.length; i++)
            ISCIncident.internalBinaryWrite(message.incidents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string overall_risk = 2; */
        if (message.overallRisk !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.overallRisk);
        /* repeated string errors = 3; */
        for (let i = 0; i < message.errors.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.errors[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message service.ISCSecurityResult
 */
export const ISCSecurityResult = new ISCSecurityResult$Type();
/**
 * @generated ServiceType for protobuf service service.AuthService
 */
export const AuthService = new ServiceType("service.AuthService", [
    { name: "CreateUser", options: {}, I: CreateUserRequest, O: CreateUserResponse },
    { name: "GetUser", options: {}, I: GetUserRequest, O: GetUserResponse },
    { name: "UpdateUser", options: {}, I: UpdateUserRequest, O: UpdateUserResponse },
    { name: "DeleteUser", options: {}, I: DeleteUserRequest, O: DeleteUserResponse },
    { name: "ListUsers", options: {}, I: ListUsersRequest, O: ListUsersResponse },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "InviteUser", options: {}, I: InviteUserRequest, O: InviteUserResponse },
    { name: "ValidateInvite", options: {}, I: ValidateInviteRequest, O: ValidateInviteResponse }
]);
/**
 * @generated ServiceType for protobuf service service.UserService
 */
export const UserService = new ServiceType("service.UserService", [
    { name: "CreateAPIKey", options: {}, I: CreateAPIKeyRequest, O: CreateAPIKeyResponse },
    { name: "RotateAPIKey", options: {}, I: RotateAPIKeyRequest, O: RotateAPIKeyResponse },
    { name: "ActivateAPIKey", options: {}, I: ActivateAPIKeyRequest, O: ActivateAPIKeyResponse },
    { name: "DeactivateAPIKey", options: {}, I: DeactivateAPIKeyRequest, O: DeactivateAPIKeyResponse },
    { name: "ListAPIKeys", options: {}, I: ListAPIKeysRequest, O: ListAPIKeysResponse },
    { name: "ChangePassword", options: {}, I: ChangePasswordRequest, O: ChangePasswordResponse }
]);
/**
 * @generated ServiceType for protobuf service service.ScanService
 */
export const ScanService = new ServiceType("service.ScanService", [
    { name: "ScanDomain", options: {}, I: ScanDomainRequest, O: ScanDomainResponse },
    { name: "ScanTLS", options: {}, I: ScanTLSRequest, O: ScanTLSResponse },
    { name: "ScanCrtSh", options: {}, I: ScanCrtShRequest, O: ScanCrtShResponse },
    { name: "ScanChaos", options: {}, I: ScanChaosRequest, O: ScanChaosResponse },
    { name: "ScanShodan", options: {}, I: ScanShodanRequest, O: ScanShodanResponse },
    { name: "ScanOTX", options: {}, I: ScanOTXRequest, O: ScanOTXResponse },
    { name: "ScanWhois", options: {}, I: ScanWhoisRequest, O: ScanWhoisResponse },
    { name: "ScanAbuseCh", options: {}, I: ScanAbuseChRequest, O: ScanAbuseChResponse },
    { name: "ScanISC", options: {}, I: ScanISCRequest, O: ScanISCResponse },
    { name: "GetDNSScanResultsByDomain", options: {}, I: GetDNSScanResultsByDomainRequest, O: GetDNSScanResultsByDomainResponse },
    { name: "GetTLSScanResultsByDomain", options: {}, I: GetTLSScanResultsByDomainRequest, O: GetTLSScanResultsByDomainResponse },
    { name: "GetCrtShScanResultsByDomain", options: {}, I: GetCrtShScanResultsByDomainRequest, O: GetCrtShScanResultsByDomainResponse },
    { name: "GetChaosScanResultsByDomain", options: {}, I: GetChaosScanResultsByDomainRequest, O: GetChaosScanResultsByDomainResponse },
    { name: "GetShodanScanResultsByDomain", options: {}, I: GetShodanScanResultsByDomainRequest, O: GetShodanScanResultsByDomainResponse },
    { name: "GetOTXScanResultsByDomain", options: {}, I: GetOTXScanResultsByDomainRequest, O: GetOTXScanResultsByDomainResponse },
    { name: "GetWhoisScanResultsByDomain", options: {}, I: GetWhoisScanResultsByDomainRequest, O: GetWhoisScanResultsByDomainResponse },
    { name: "GetAbuseChScanResultsByDomain", options: {}, I: GetAbuseChScanResultsByDomainRequest, O: GetAbuseChScanResultsByDomainResponse },
    { name: "GetISCScanResultsByDomain", options: {}, I: GetISCScanResultsByDomainRequest, O: GetISCScanResultsByDomainResponse },
    { name: "GetDNSScanResultByID", options: {}, I: GetDNSScanResultByIDRequest, O: GetDNSScanResultByIDResponse }
]);
/**
 * @generated ServiceType for protobuf service service.ReportService
 */
export const ReportService = new ServiceType("service.ReportService", [
    { name: "GenerateReport", options: {}, I: GenerateReportRequest, O: GenerateReportResponse },
    { name: "ListReports", options: {}, I: ListReportsRequest, O: ListReportsResponse },
    { name: "GetReportById", options: {}, I: GetReportByIdRequest, O: GetReportByIdResponse },
    { name: "CalculateRiskScore", options: {}, I: CalculateRiskScoreRequest, O: CalculateRiskScoreResponse }
]);
